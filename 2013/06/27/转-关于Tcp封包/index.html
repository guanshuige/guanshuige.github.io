<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[转]关于Tcp封包 | 观水阁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="写的很优秀的一篇文章,转过来给大家看一下,转自http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html.感谢博主辛苦原创
很多朋友已经对此作了不少研究，也花费不少心血编写了实现代码和blog文档。当然也充斥着一些各式的评论，自己看了一下，总结一些心得。
首先我们学习一下这些朋友的心得，他们是：
http://blog.csdn">
<meta property="og:type" content="article">
<meta property="og:title" content="[转]关于Tcp封包">
<meta property="og:url" content="http://yoursite.com/2013/06/27/转-关于Tcp封包/index.html">
<meta property="og:site_name" content="观水阁">
<meta property="og:description" content="写的很优秀的一篇文章,转过来给大家看一下,转自http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html.感谢博主辛苦原创
很多朋友已经对此作了不少研究，也花费不少心血编写了实现代码和blog文档。当然也充斥着一些各式的评论，自己看了一下，总结一些心得。
首先我们学习一下这些朋友的心得，他们是：
http://blog.csdn">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733121496.jpg">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733185885.jpg">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733224094.jpg">
<meta property="og:image" content="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733251811.jpg">
<meta property="og:updated_time" content="2016-10-20T08:24:51.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转]关于Tcp封包">
<meta name="twitter:description" content="写的很优秀的一篇文章,转过来给大家看一下,转自http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html.感谢博主辛苦原创
很多朋友已经对此作了不少研究，也花费不少心血编写了实现代码和blog文档。当然也充斥着一些各式的评论，自己看了一下，总结一些心得。
首先我们学习一下这些朋友的心得，他们是：
http://blog.csdn">
<meta name="twitter:image" content="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733121496.jpg">
  
    <link rel="alternate" href="/atom.xml" title="观水阁" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">观水阁</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-转-关于Tcp封包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/27/转-关于Tcp封包/" class="article-date">
  <time datetime="2013-06-27T07:14:58.000Z" itemprop="datePublished">2013-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [转]关于Tcp封包
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写的很优秀的一篇文章,转过来给大家看一下,转自<a href="http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html" target="_blank" rel="external">http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html</a>.感谢博主辛苦原创</p>
<p>很多朋友已经对此作了不少研究，也花费不少心血编写了实现代码和blog文档。当然也充斥着一些各式的评论，自己看了一下，总结一些心得。</p>
<p>首先我们学习一下这些朋友的心得，他们是：</p>
<p><a href="http://blog.csdn.net/stamhe/article/details/4569530" target="_blank" rel="external">http://blog.csdn.net/stamhe/article/details/4569530</a></p>
<p><a href="http://www.cppblog.com/tx7do/archive/2011/05/04/145699.html" target="_blank" rel="external">http://www.cppblog.com/tx7do/archive/2011/05/04/145699.html</a></p>
<p>//………………</p>
<p>当然还有太多，很多东西粘来粘区也不知道到底是谁的原作,J</p>
<p>看这些朋友的blog是我建议亲自看一下TCP-IP详解卷1中的相关内容【原理性的内容一定要看】。</p>
<h2 id="TCP大致工作原理介绍："><a href="#TCP大致工作原理介绍：" class="headerlink" title="TCP大致工作原理介绍："></a>TCP大致工作原理介绍：</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>TCP-IP详解卷1第17章中17.2节对TCP服务原理作了一个简明介绍(以下蓝色字体摘自《TCP-IP详解卷1第17章17.2节》)：</p>
<p><span style="color:#3366ff">尽管</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">都使用相同的网络层（</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">），</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">却向应用层提供与</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">完全不同的服务。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">提供一种面向连接的、可靠的字节流服务。</span></p>
<p><span style="color:#3366ff">面向连接意味着两个使用</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接。这一过程与打电话很相&#20284;，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在第</span><span style="color:#3366ff">1<br> 8</span><span style="color:#3366ff">章我们将看到一个</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接是如何建立的，以及当一方通信结束后如何断开连接。</span></p>
<p><span style="color:#3366ff">在一个</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接中，仅有两方进行彼此通信。在第</span><span style="color:#3366ff">1 2</span><span style="color:#3366ff">章介绍的广播和多播不能用于</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">T C P</span><span style="color:#3366ff">通过下列方式来提供可靠性：</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">应用数据被分割成</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">认为最适合发送的数据块。这和</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">完全不同，应用程序产生的数据报长度将保持不变。由</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">传递给</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">的信息单位称为报文段或段（</span><span style="color:#3366ff">s e g m e n t</span><span style="color:#3366ff">）（参见图</span><span style="color:#3366ff">1 - 7</span><span style="color:#3366ff">）。在</span><span style="color:#3366ff">1<br> 8 . 4</span><span style="color:#3366ff">节我们将看到</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">如何确定报文段的长度。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">当</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。在第</span><span style="color:#3366ff">2 1</span><span style="color:#3366ff">章我们将了解</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">协议中自适应的超时及重传策略。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">当</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">收到发自</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒，这将在</span><span style="color:#3366ff">1<br> 9 . 3</span><span style="color:#3366ff">节讨论。</span></p>
<p><span style="color:#3366ff">• T C P</span><span style="color:#3366ff">将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">既然</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">报文段作为</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报来传输，而</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">数据报的到达可能会失序，因此</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">报文段的到达也可能会失序。如果必要，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">既然</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报会发生重复，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">的接收端必须丢弃重复的数据。</span></p>
<p><span style="color:#3366ff">• T C P</span><span style="color:#3366ff">还能提供流量控制。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接的每一方都有固定大小的缓冲空间。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。两个应用程序通过</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">连接交换</span><span style="color:#3366ff">8 bit</span><span style="color:#3366ff">字节构成的字节流。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">不在字节流中插入记录标识符。我们将这称为字节流服务（</span><span style="color:#3366ff">byte<br> stream service</span><span style="color:#3366ff">）。如果一方的应用程序先传</span><span style="color:#3366ff">1 0</span><span style="color:#3366ff">字节，又传</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节，再传</span><span style="color:#3366ff">5 0</span><span style="color:#3366ff">字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分</span><span style="color:#3366ff">4</span><span style="color:#3366ff">次接收这</span><span style="color:#3366ff">8<br> 0</span><span style="color:#3366ff">个字节，每次接收</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节。一端将字节流放到</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接上，同样的字节流将出现在</span><span style="color:#3366ff">T C<br> P</span><span style="color:#3366ff">连接的另一端。另外，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">对字节流的内容不作任何解释。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">不知道传输的数据字节流是二进制数据，还是</span><span style="color:#3366ff">A<br> S C I I</span><span style="color:#3366ff">字符、</span><span style="color:#3366ff">E B C D I C</span><span style="color:#3366ff">字符或者其他类型数据。对字节流的解释由</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接双方的应用层解释。这种对字节流的处理方式与</span><span style="color:#3366ff">U<br> n i x</span><span style="color:#3366ff">操作系统对文件的处理方式很相&#20284;。</span><span style="color:#3366ff">U n i x</span><span style="color:#3366ff">的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对</span><span style="color:#3366ff">U n i x</span><span style="color:#3366ff">的内核来说，它无法区分一个二进制文件与一个文本文件。</span></p>
<h3 id="T-C-P如何确定报文段的长度"><a href="#T-C-P如何确定报文段的长度" class="headerlink" title="T C P如何确定报文段的长度"></a>T C P如何确定报文段的长度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我仍然引用官方解释《TCP-IP详解卷1》第18章18.4节：</p>
<p><span style="color:#3366ff">最大报文段长度（ </span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">）表示</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">传往另一端的最大块数据的长度。当一个连接建立时【三次握手】，连接的双方都要通告各自的</span><span style="color:#3366ff">M<br> S S</span><span style="color:#3366ff">。我们已经见过</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">都是</span><span style="color:#3366ff">1 0 2 4</span><span style="color:#3366ff">。这导致</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报通常是</span><span style="color:#3366ff">4<br> 0</span><span style="color:#3366ff">字节长：</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部和</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">首部。</span></p>
<p><span style="color:#3366ff">在有些书中，将它看作可“协商”选项。它并不是任何条件下都可协商。当建立一个连</span></p>
<p><span style="color:#3366ff">接时，每一方都有用于通告它期望接收的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">选项（</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">选项只能出现在</span><span style="color:#3366ff">S<br> Y N</span><span style="color:#3366ff">报文段中）。如果一方不接收来自另一方的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">&#20540;，则</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">就定为默认&#20540;</span><span style="color:#3366ff">5 3 6</span><span style="color:#3366ff">字节（这个默认&#20540;允许</span><span style="color:#3366ff">2<br> 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">首部和</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部以适合</span><span style="color:#3366ff">5<br> 7 6</span><span style="color:#3366ff">字节</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报</span><span style="color:#3366ff">)</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">一般说来，如果没有分段发生， </span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">还是越大越好（这也并不总是正确，参见图</span><span style="color:#3366ff">2 4 - 3</span><span style="color:#3366ff">和图</span><span style="color:#3366ff">2<br> 4 - 4</span><span style="color:#3366ff">中的例子）。报文段越大允许每个报文段传送的数据就越多，相对</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部有更高的网络利用率。当</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">发送一个</span><span style="color:#3366ff">S Y N</span><span style="color:#3366ff">时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它能将</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">&#20540;设置为外出接口上的</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">长度减去固定的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">首部和</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部长度。对于一个以太网，</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">&#20540;可达</span><span style="color:#3366ff">1<br> 4 6 0</span><span style="color:#3366ff">字节。使用</span><span style="color:#3366ff">IEEE 802.3</span><span style="color:#3366ff">的封装（参见</span><span style="color:#3366ff">2 . 2</span><span style="color:#3366ff">节），它的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">可达</span><span style="color:#3366ff">1<br> 4 5 2</span><span style="color:#3366ff">字节。</span></p>
<p><span style="color:#3366ff">如果目的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">地址为“非本地的</span><span style="color:#3366ff">( n o n l o c a l )</span><span style="color:#3366ff">”，</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">通常的默认&#20540;为</span><span style="color:#3366ff">5<br> 3 6</span><span style="color:#3366ff">。而区分地址是本地还是非本地是简单的，如果目的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">地址的网络号与子网号都和我们的相同，则是本地的；如果目的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">地址的网络号与我们的完全不同，则是非本地的；如果目的</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。大多数</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">实现版都提供了一个配置选项（附录</span><span style="color:#3366ff">E</span><span style="color:#3366ff">和图</span><span style="color:#3366ff">E</span></p>
<ul>
<li>1<span style="color:#3366ff">），让系统管理员说明不同的子网是属于本地还是非本地。这个选项的设置将确定</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">可以选择尽可能的大（达到外出接口的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">长度）或是默认&#20540;</span><span style="color:#3366ff">5<br>3 6</span><span style="color:#3366ff">。</span></li>
</ul>
<p><span style="color:#3366ff">M S S</span><span style="color:#3366ff">让主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这将使以较小</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">连接到一个网络上的主机避免分段。</span></p>
<p><span style="color:#3366ff">只有当一端的主机以小于</span><span style="color:#3366ff">5 7 6</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">直接连接到一个网络中，避免这种分段才会有效。</span></p>
<p><span style="color:#3366ff">如果两端的主机都连接到以太网上，都采用</span><span style="color:#3366ff">5 3 6</span><span style="color:#3366ff">的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">，但中间网络采用</span><span style="color:#3366ff">2 9 6</span><span style="color:#3366ff">的</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">，也将会</span></p>
<p><span style="color:#3366ff">出现分段。使用路径上的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">发现机制（参见</span><span style="color:#3366ff">2 4 . 2</span><span style="color:#3366ff">节）是关于这个问题的唯一方法。</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以上说明MSS的&#20540;可以通过协商解决，这个协商过程会涉及MTU的&#20540;的大小，前面说了：【MSS=外出接口上的MTU-IP首部-TCP首部】，我们来看看数据进入TCP协议栈的封装过程：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733115740.jpg" target="_blank" rel="external"><br><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733121496.jpg" alt="clip_image002" title="clip_image002"></a></p>
<p>最后一层以太网帧的大小应该就是我们的出口ＭＴＵ大小了。当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（ D e m u l t i p l e x i n g），图1 - 8显示了该过程是如何发生的。</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733178493.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733185885.jpg" alt="clip_image004" title="clip_image004"></a></p>
<p>那么什么是MTU呢，这实际上是数据链路层的一个概念，以太网和802.3这两种局域网技术标准都对“链路层”的数据帧有大小限制：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733203735.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733224094.jpg" alt="clip_image006" title="clip_image006"></a></p>
<p><span style="color:#3366ff">l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3366ff">最大传输单元</span><span style="color:#3366ff">MTU</span></p>
<p><span style="color:#3366ff">正如在图</span><span style="color:#3366ff">2 - 1</span><span style="color:#3366ff">看到的那样，以太网和</span><span style="color:#3366ff">8 0 2 . 3</span><span style="color:#3366ff">对数据帧的长度都有一个限制，其最大&#20540;分别是</span><span style="color:#3366ff">1<br> 5 0 0</span><span style="color:#3366ff">和</span><span style="color:#3366ff">1 4 9 2</span><span style="color:#3366ff">字节。链路层的这个特性称作</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">，最大传输单元。不同类型的网络大多数都有一个上限。</span></p>
<p><span style="color:#3366ff">如果</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">层有一个数据报要传，而且数据的长度比链路层的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">还大，那么</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">层就需要进行分片（</span><span style="color:#3366ff"><br> f r a g m e n t a t i o n</span><span style="color:#3366ff">），把数据报分成若干片，这样每一片都小于</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。我们将在</span><span style="color:#3366ff">11 . 5</span><span style="color:#3366ff">节讨论</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">分片的过程。</span></p>
<p><span style="color:#3366ff">图</span><span style="color:#3366ff">2 - 5</span><span style="color:#3366ff">列出了一些典型的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">&#20540;，它们摘自</span><span style="color:#3366ff">RFC 1191[Mogul and Deering<br> 1990]</span><span style="color:#3366ff">。点到点的链路层（如</span><span style="color:#3366ff">S L I P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">P P P</span><span style="color:#3366ff">）的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">并非指的是网络媒体的物理特性。相反，它是一个逻辑限制，目的是为交互使用提供足够快的响应时间。在</span><span style="color:#3366ff">2<br> . 1 0</span><span style="color:#3366ff">节中，我们将看到这个限制&#20540;是如何计算出来的。在</span><span style="color:#3366ff">3 . 9</span><span style="color:#3366ff">节中，我们将用</span><span style="color:#3366ff">n e t s t a t</span><span style="color:#3366ff">命令打印出网络接口的</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3366ff">路径</span><span style="color:#3366ff">MTU</span></p>
<p><span style="color:#3366ff">当在同一个网络上的两台主机互相进行通信时，该网络的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">是非常重要的。但是如果</span></p>
<p><span style="color:#3366ff">两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。重要的</span></p>
<p><span style="color:#3366ff">不是两台主机所在网络的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的&#20540;，重要的是两台通信主机路径中的最小</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。它被称作路</span></p>
<p><span style="color:#3366ff">径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">两台主机之间的路径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">不一定是个常数。它取决于当时所选择的路由。而选路不一定</span></p>
<p><span style="color:#3366ff">是对称的（从</span><span style="color:#3366ff">A</span><span style="color:#3366ff">到</span><span style="color:#3366ff">B</span><span style="color:#3366ff">的路由可能与从</span><span style="color:#3366ff">B</span><span style="color:#3366ff">到</span><span style="color:#3366ff">A</span><span style="color:#3366ff">的路由不同），因此路径</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">在两个方向上不一定是</span></p>
<p><span style="color:#3366ff">一致的。</span></p>
<p><span style="color:#3366ff">RFC 1191[Mogul and Deering 1990]</span><span style="color:#3366ff">描述了路径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的发现机制，即在任何时候确定路径</span></p>
<p><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的方法。我们在介绍了</span><span style="color:#3366ff">I C M P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">分片方法以后再来看它是如何操作的。在</span><span style="color:#3366ff">11<br> . 6</span><span style="color:#3366ff">节中，我</span></p>
<p><span style="color:#3366ff">们将看到</span><span style="color:#3366ff">I C M P</span><span style="color:#3366ff">的不可到达错误就采用这种发现方法。在</span><span style="color:#3366ff">11 . 7</span><span style="color:#3366ff">节中，还会看到，</span><span style="color:#3366ff"> t r a c<br> e r o u t e</span><span style="color:#3366ff">程序</span></p>
<p><span style="color:#3366ff">也是用这个方法来确定到达目的节点的路径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。在</span><span style="color:#3366ff">11 . 8</span><span style="color:#3366ff">节和</span><span style="color:#3366ff">2 4 . 2</span><span style="color:#3366ff">节，将介绍当产品支持路</span></p>
<p><span style="color:#3366ff">径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的发现方法时，</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">是如何进行操作的。</span></p>
<h3 id="TCP的超时与重传"><a href="#TCP的超时与重传" class="headerlink" title="ＴＣＰ的超时与重传"></a>ＴＣＰ的超时与重传</h3><p><span style="color:#3366ff">前面谈到TCP</span>如何保证传输可靠性是说到“当<span style="color:#3366ff">T C P</span><span style="color:#3366ff">发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段”，下面我看一下TCP</span>的超时与重传。</p>
<p><span style="color:#3366ff">T C P</span><span style="color:#3366ff">提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。</span></p>
<p><span style="color:#3366ff">对每个连接，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">管理</span><span style="color:#3366ff">4</span><span style="color:#3366ff">个不同的定时器。</span></p>
<p><span style="color:#3366ff">1) </span><span style="color:#3366ff">重传定时器使用于当希望收到另一端的确认。</span></p>
<p><span style="color:#3366ff">2) </span><span style="color:#3366ff">坚持</span><span style="color:#3366ff">( p e r s i s t )</span><span style="color:#3366ff">定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。</span></p>
<p><span style="color:#3366ff">3) </span><span style="color:#3366ff">保活</span><span style="color:#3366ff">( k e e p a l i v e )</span><span style="color:#3366ff">定时器可检测到一个空闲连接的另一端何时崩溃或重启。</span></p>
<p><span style="color:#3366ff">4) 2MSL</span><span style="color:#3366ff">定时器测量一个连接处于</span><span style="color:#3366ff">T I M E _ WA I T</span><span style="color:#3366ff">状态的时间。</span></p>
<p><span style="color:#3366ff">T C P</span><span style="color:#3366ff">超时与重传中最重要的部分就是对一个给定连接的往返时间（</span><span style="color:#3366ff"> RT T</span><span style="color:#3366ff">）的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，</span><span style="color:#3366ff"> T C P</span><span style="color:#3366ff">应该跟踪这些变化并相应地改变其超时时间。</span></p>
<p><span style="color:#3366ff">大多数源于伯克利的</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">实现在任何时候对每个连接仅测量一次</span><span style="color:#3366ff">RT T</span><span style="color:#3366ff">&#20540;。在发送一个报文段时，如果给定连接的定时器已经被使用，则该报文段不被计时。</span></p>
<p><span style="color:#3366ff">具体</span><span style="color:#3366ff">RTT</span><span style="color:#3366ff">&#20540;的估算比较麻烦，需要可以参考《</span><span style="color:#3366ff">TCP-IP</span><span style="color:#3366ff">详解卷</span><span style="color:#3366ff">1</span><span style="color:#3366ff">第</span><span style="color:#3366ff">21</span><span style="color:#3366ff">章》</span></p>
<h3 id="TCP经受延时的确认"><a href="#TCP经受延时的确认" class="headerlink" title="TCP经受延时的确认"></a>TCP经受延时的确认</h3><p><span style="color:#3366ff">交互数据总是以小于最大报文段长度的分组发送。对于这些小的报文段，接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">通常</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">在接收到数据时并不立即发送</span><span style="color:#3366ff">A C K</span><span style="color:#3366ff">；相反，它推迟发送，以便将</span><span style="color:#3366ff">A C K</span><span style="color:#3366ff">与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带</span><span style="color:#3366ff">A<br> C K</span><span style="color:#3366ff">）。绝大多数实现采用的时延为</span><span style="color:#3366ff">200 ms</span><span style="color:#3366ff">，也就是说，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">将以最大</span><span style="color:#3366ff">200 ms</span><span style="color:#3366ff">的时延等待是否有数据一起发送。</span></p>
<p>我们看看另一位朋友的blog对此的介绍：</p>
<p><span style="color:green">摘要：当使用</span><span style="color:green">TCP</span><span style="color:green">传输小型数据包时，程序的设计是相当重要的。如果在设计方案中不对</span><span style="color:green">TCP</span><span style="color:green">数据包的</span><span style="color:green"></span></p>
<p><span style="color:green">延迟应答，</span><span style="color:green">Nagle</span><span style="color:green">算法，</span><span style="color:green">Winsock</span><span style="color:green">缓冲作用引起重视，将会严重影响程序的性能。这篇文章讨论了这些</span><span style="color:green"></span></p>
<p><span style="color:green">问题，列举了两个案例，给出了一些传输小数据包的优化设计方案。</span></p>
<p><span style="color:green">背景：当</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈接收到一个数据包时，会启动一个</span><span style="color:green">200</span><span style="color:green">毫秒的计时器。当</span><span style="color:green">ACK</span><span style="color:green">确认数据包</span><span style="color:green"></span></p>
<p><span style="color:green">发出之后，计时器会复位，接收到下一个数据包时，会再次启动</span><span style="color:green">200</span><span style="color:green">毫秒的计时器。为了提升应用程序</span><span style="color:green"></span></p>
<p><span style="color:green">在内部网和</span><span style="color:green">Internet</span><span style="color:green">上的传输性能，</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈使用了下面的策略来决定在接收到数据包后</span><span style="color:green"></span></p>
<p><span style="color:green">什么时候发送</span><span style="color:green">ACK</span><span style="color:green">确认数据包：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、如果在</span><span style="color:green">200</span><span style="color:green">毫秒的计时器超时之前，接收到下一个数据包，则立即发送</span><span style="color:green">ACK</span><span style="color:green">确认数据包。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、如果当前恰好有数据包需要发给</span><span style="color:green">ACK</span><span style="color:green">确认信息的接收端，则把</span><span style="color:green">ACK</span><span style="color:green">确认信息附带在数据包上立即发送。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、当计时器超时，</span><span style="color:green">ACK</span><span style="color:green">确认信息立即发送。</span><span style="color:green"></span></p>
<p><span style="color:green">为了避免小数据包拥塞网络，</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈默认启用了</span><span style="color:green">Nagle</span><span style="color:green">算法，这个算法能够将应用程序多次</span><span style="color:green"></span></p>
<p><span style="color:green">调用</span><span style="color:green">Send</span><span style="color:green">发送的数据拼接起来，当收到前一个数据包的</span><span style="color:green">ACK</span><span style="color:green">确认信息时，一起发送出去。下面是</span><span style="color:green">Nagle&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">算法的例外情况：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、如果</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈拼接起来的数据包超过了</span><span style="color:green">MTU</span><span style="color:green">&#20540;，这个数据会立即发送，而不等待前一个数据</span><span style="color:green"></span></p>
<p><span style="color:green">包的</span><span style="color:green">ACK</span><span style="color:green">确认信息。在以太网中，</span><span style="color:green">TCP</span><span style="color:green">的</span><span style="color:green">MTU(Maximum Transmission Unit)</span><span style="color:green">&#20540;是</span><span style="color:green">1460</span><span style="color:green">字节。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、如果设置了</span><span style="color:green">TCP_NODELAY</span><span style="color:green">选项，就会禁用</span><span style="color:green">Nagle</span><span style="color:green">算法，应用程序调用</span><span style="color:green">Send</span><span style="color:green">发送的数据包会立即被</span><span style="color:green"></span></p>
<p><span style="color:green">投递到网络，而没有延迟。</span><span style="color:green"></span></p>
<p><span style="color:green">为了在应用层优化性能，</span><span style="color:green">Winsock</span><span style="color:green">把应用程序调用</span><span style="color:green">Send</span><span style="color:green">发送的数据从应用程序的缓冲区复制到</span><span style="color:green">Winsock&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">内核缓冲区。</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈利用类&#20284;</span><span style="color:green">Nagle</span><span style="color:green">算法的方法，决定什么时候才实际地把数据投递到网络。</span><span style="color:green"></span></p>
<p><span style="color:green">内核缓冲区的默认大小是</span><span style="color:green">8K</span><span style="color:green">，使用</span><span style="color:green">SO_SNDBUF</span><span style="color:green">选项，可以改变</span><span style="color:green">Winsock</span><span style="color:green">内核缓冲区的大小。如果有必要的话，</span><span style="color:green"></span></p>
<p>Winsock<span style="color:green">能缓冲大于</span><span style="color:green">SO_SNDBUF</span><span style="color:green">缓冲区大小的数据。在绝大多数情况下，应用程序完成</span><span style="color:green">Send</span><span style="color:green">调用仅仅表明数据</span><span style="color:green"></span></p>
<p><span style="color:green">被复制到了</span><span style="color:green">Winsock</span><span style="color:green">内核缓冲区，并不能说明数据就实际地被投递到了网络上。唯一一种例外的情况是：</span><span style="color:green"></span></p>
<p><span style="color:green">通过设置</span><span style="color:green">SO_SNDBUT</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">禁用了</span><span style="color:green">Winsock</span><span style="color:green">内核缓冲区。</span></p>
<p><span style="color:green">Winsock</span><span style="color:green">使用下面的规则来向应用程序表明一个</span><span style="color:green">Send</span><span style="color:green">调用的完成：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、如果</span><span style="color:green">socket</span><span style="color:green">仍然在</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额内，</span><span style="color:green">Winsock</span><span style="color:green">复制应用程序要发送的数据到内核缓冲区，完成</span><span style="color:green">Send</span><span style="color:green">调用。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、如果</span><span style="color:green">Socket</span><span style="color:green">超过了</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额并且先前只有一个被缓冲的发送数据在内核缓冲区，</span><span style="color:green">Winsock</span><span style="color:green">复制要发送</span><span style="color:green"></span></p>
<p><span style="color:green">的数据到内核缓冲区，完成</span><span style="color:green">Send</span><span style="color:green">调用。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、如果</span><span style="color:green">Socket</span><span style="color:green">超过了</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额并且内核缓冲区有不只一个被缓冲的发送数据，</span><span style="color:green">Winsock</span><span style="color:green">复制要发送的数据</span><span style="color:green"></span></p>
<p><span style="color:green">到内核缓冲区，然后投递数据到网络，直到</span><span style="color:green">Socket</span><span style="color:green">降到</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额内或者只剩余一个要发送的数据，才</span><span style="color:green"></span></p>
<p><span style="color:green">完成</span><span style="color:green">Send</span><span style="color:green">调用。</span></p>
<p><span style="color:green">案例</span><span style="color:green">1&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">一个</span><span style="color:green">Winsock TCP</span><span style="color:green">客户端需要发送</span><span style="color:green">10000</span><span style="color:green">个记录到</span><span style="color:green">Winsock TCP</span><span style="color:green">服务端，保存到数据库。记录大小从</span><span style="color:green">20</span><span style="color:green">字节到</span><span style="color:green">100&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">字节不等。对于简单的应用程序逻辑，可能的设计方案如下：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、客户端以阻塞方式发送，服务端以阻塞方式接收。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、客户端设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">，禁用</span><span style="color:green">Nagle</span><span style="color:green">算法，让每个数据包单独的发送。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、服务端在一个循环中调用</span><span style="color:green">Recv</span><span style="color:green">接收数据包。给</span><span style="color:green">Recv</span><span style="color:green">传递</span><span style="color:green">200</span><span style="color:green">字节的缓冲区以便让每个记录在一次</span><span style="color:green">Recv</span><span style="color:green">调用中</span><span style="color:green"></span></p>
<p><span style="color:green">被获取到。</span></p>
<p><span style="color:green">性能：</span><span style="color:green"></span></p>
<p><span style="color:green">在测试中发现，客户端每秒只能发送</span><span style="color:green">5</span><span style="color:green">条数据到服务段，总共</span><span style="color:green">10000</span><span style="color:green">条记录，</span><span style="color:green">976K</span><span style="color:green">字节左右，用了半个多小时</span><span style="color:green"></span></p>
<p><span style="color:green">才全部传到服务器。</span></p>
<p><span style="color:green">分析：</span><span style="color:green"></span></p>
<p><span style="color:green">因为客户端没有设置</span><span style="color:green">TCP_NODELAY</span><span style="color:green">选项，</span><span style="color:green">Nagle</span><span style="color:green">算法强制</span><span style="color:green">TCP</span><span style="color:green">栈在发送数据包之前等待前一个数据包的</span><span style="color:green">ACK</span><span style="color:green">确认</span><span style="color:green"></span></p>
<p><span style="color:green">信息。然而，客户端设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">，禁用了内核缓冲区。因此，</span><span style="color:green">10000</span><span style="color:green">个</span><span style="color:green">Send</span><span style="color:green">调用只能一个数据包一个数据</span><span style="color:green"></span></p>
<p><span style="color:green">包的发送和确认，由于下列原因，每个</span><span style="color:green">ACK</span><span style="color:green">确认信息被延迟</span><span style="color:green">200</span><span style="color:green">毫秒：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、当服务器获取到一个数据包，启动一个</span><span style="color:green">200</span><span style="color:green">毫秒的计时器。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、服务端不需要向客户端发送任何数据，所以，</span><span style="color:green">ACK</span><span style="color:green">确认信息不能被发回的数据包顺路携带。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、客户端在没有收到前一个数据包的确认信息前，不能发送数据包。</span><span style="color:green"></span></p>
<p>4<span style="color:green">、服务端的计时器超时后，</span><span style="color:green">ACK</span><span style="color:green">确认信息被发送到客户端。</span></p>
<p><span style="color:green">如何提高性能：</span><span style="color:green"></span></p>
<p><span style="color:green">在这个设计中存在两个问题。第一，存在延时问题。客户端需要能够在</span><span style="color:green">200</span><span style="color:green">毫秒内发送两个数据包到服务端。</span><span style="color:green"></span></p>
<p><span style="color:green">因为客户端默认情况下使用</span><span style="color:green">Nagle</span><span style="color:green">算法，应该使用默认的内核缓冲区，不应该设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">。一旦</span><span style="color:green">TCP&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">栈拼接起来的数据包超过</span><span style="color:green">MTU</span><span style="color:green">&#20540;，这个数据包会立即被发送，不用等待前一个</span><span style="color:green">ACK</span><span style="color:green">确认信息。第二，这个设计</span><span style="color:green"></span></p>
<p><span style="color:green">方案对每一个如此小的的数据包都调用一次</span><span style="color:green">Send</span><span style="color:green">。发送这么小的数据包是不很有效率的。在这种情况下，应该</span><span style="color:green"></span></p>
<p><span style="color:green">把每个记录补充到</span><span style="color:green">100</span><span style="color:green">字节并且每次调用</span><span style="color:green">Send</span><span style="color:green">发送</span><span style="color:green">80</span><span style="color:green">个记录。为了让服务端知道一次总共发送了多少个记录，</span><span style="color:green"></span></p>
<p><span style="color:green">客户端可以在记录前面带一个头信息。</span></p>
<p><span style="color:green">案例二：</span><span style="color:green"></span></p>
<p><span style="color:green">一个</span><span style="color:green">Winsock TCP</span><span style="color:green">客户端程序打开两个连接和一个提供股票报价服务的</span><span style="color:green">Winsock TCP</span><span style="color:green">服务端通信。第一个连接</span><span style="color:green"></span></p>
<p><span style="color:green">作为命令通道用来传输股票编号到服务端。第二个连接作为数据通道用来接收股票报价。两个连接被建立后，</span><span style="color:green"></span></p>
<p><span style="color:green">客户端通过命令通道发送股票编号到服务端，然后在数据通道上等待返回的股票报价信息。客户端在接收到第一</span><span style="color:green"></span></p>
<p><span style="color:green">个股票报价信息后发送下一个股票编号请求到服务端。客户端和服务端都没有设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">和</span><span style="color:green">TCP_NODELAY&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">选项。</span></p>
<p><span style="color:green">性能：</span><span style="color:green"></span></p>
<p><span style="color:green">测试中发现，客户端每秒只能获取到</span><span style="color:green">5</span><span style="color:green">条报价信息。</span></p>
<p><span style="color:green">分析：</span></p>
<p><span style="color:green">这个设计方案一次只允许获取一条股票信息。第一个股票编号信息通过命令通道发送到服务端，立即接收到</span><span style="color:green"></span></p>
<p><span style="color:green">服务端通过数据通道返回的股票报价信息。然后，客户端立即发送第二条请求信息，</span><span style="color:green">send</span><span style="color:green">调用立即返回，</span><span style="color:green"></span></p>
<p><span style="color:green">发送的数据被复制到内核缓冲区。然而，</span><span style="color:green">TCP</span><span style="color:green">栈不能立即投递这个数据包到网络，因为没有收到前一个数据包的</span><span style="color:green"></span></p>
<p>ACK<span style="color:green">确认信息。</span><span style="color:green">200</span><span style="color:green">毫秒后，服务端的计时器超时，第一个请求数据包的</span><span style="color:green">ACK</span><span style="color:green">确认信息被发送回客户端，客户端</span><span style="color:green"></span></p>
<p><span style="color:green">的第二个请求包才被投递到网络。第二个请求的报价信息立即从数据通道返回到客户端，因为此时，客户端的</span><span style="color:green"></span></p>
<p><span style="color:green">计时器已经超时，第一个报价信息的</span><span style="color:green">ACK</span><span style="color:green">确认信息已经被发送到服务端。这个过程循环发生。</span></p>
<p><span style="color:green">如何提高性能：</span><span style="color:green"></span></p>
<p><span style="color:green">在这里，两个连接的设计是没有必要的。如果使用一个连接来请求和接收报价信息，股票请求的</span><span style="color:green">ACK</span><span style="color:green">确认信息会</span><span style="color:green"></span></p>
<p><span style="color:green">被返回的报价信息立即顺路携带回来。要进一步的提高性能，客户端应该一次调用</span><span style="color:green">Send</span><span style="color:green">发送多个股票请求，服务端</span><span style="color:green"></span></p>
<p><span style="color:green">一次返回多个报价信息。如果由于某些特殊原因必须要使用两个单向的连接，客户端和服务端都应该设置</span><span style="color:green">TCP_NODELAY&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">选项，让小数据包立即发送而不用等待前一个数据包的</span><span style="color:green">ACK</span><span style="color:green">确认信息。</span></p>
<p>提高性能的建议：</p>
<p>上面两个案例说明了一些最坏的情况。当设计一个方案解决大量的小数据包发送和接收时，应该遵循以下的建议：</p>
<p>1、如果数据片段不需要紧急传输的话，应用程序应该将他们拼接成更大的数据块，再调用Send。因为发送缓冲区</p>
<p>很可能被复制到内核缓冲区，所以缓冲区不应该太大，通常比8K小一点点是很有效率的。只要Winsock内核缓冲区</p>
<p>得到一个大于MTU&#20540;的数据块，就会发送若干个数据包，剩下最后一个数据包。发送方除了最后一个数据包，都不会</p>
<p>被200毫秒的计时器触发。</p>
<p>2、如果可能的话，避免单向的Socket数据流接连。</p>
<p>3、不要设置SO_SNDBUF为0，除非想确保数据包在调用Send完成之后立即被投递到网络。事实上，8K的缓冲区适合大多数</p>
<p>情况，不需要重新改变，除非新设置的缓冲区经过测试的确比默认大小更高效。</p>
<p>4、如果数据传输不用保证可靠性，使用UDP。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP提供了面向“连续字节流”的可靠的传输服务，TCP并不理解流所携带的数据内容，这个内容需要应用层自己解析。</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “字节流”是连续的、非结构化的，而我们的应用需要的是有序的、结构化的数据信息，因此我们需要定义自己的“规则”去解读这个“连续的字节流“，那解决途径就是定义自己的封包类型，然后用这个类型去映射“连续字节流”。</p>
<p>如何定义封包，我们回顾一下前面这个数据进入协议栈的封装过程图：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733242750.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733251811.jpg" alt="clip_image007" title="clip_image007"></a></p>
<p>封包其实就是将上图中进入协议栈的用户数据[即用户要发送的数据]定义为一种方便识别和交流的类型，这有点类&#20284;信封的概念,信封就是一种人们之间通信的&#26684;式,信封&#26684;式如下：</p>
<p>信封&#26684;式：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收信人邮编</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收信人地址</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收信人姓名</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 信件内容</p>
<p>那么在程序里面我们也需要定义这种&#26684;式：在C&#43;&#43;里面只有结构和类这种两种类型适合表达这个概念了。网络上很多朋友对此表述了自己的看法并贴出了代码：比如</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 数据封包信息定义开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>#pragma pack(push,1)&nbsp;&nbsp; //将原对齐方式压栈,采用新的1字节对齐方式</p>
<p>/<em> 封包类型枚举[此处根据需求列举] </em>/</p>
<p>typedef enum{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NLOGIN=1,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NREG=2,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NBACKUP=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NRESTORE=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NFILE_TRANSFER=4,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NHELLO=5</p>
<p>} PACKETTYPE;</p>
<p>/<em> 包头 </em>/</p>
<p>typedef struct tagNetPacketHead{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte version;//版本</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PACKETTYPE ePType;//包类型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD nLen;//包体长度</p>
<p>} NetPacketHead;</p>
<p>/<em> 封包对象[包头&amp;包体] </em>/</p>
<p>typedef struct tagNetPacket{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacketHead netPacketHead;//包头</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * packetBody;//包体</p>
<p>} NetPacket;</p>
<p>#pragma pack(pop)</p>
<p>/<strong><strong><strong>**</strong></strong></strong>数据封包信息定义结束<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发包顺序与收包问题</p>
<p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于TCP要通过协商解决发送出去的报文段的长度，因此我们发送的数据很有可能被分割甚至被分割后再重组交给网络层发送，而网络层又是采用分组传送，即网络层数据报到达目标的顺序完全无法预测，那么收包会出现半包、粘包问题。举个例子，发送端连续发送两端数据msg1和msg2，那么发送端[传输层]可能会出现以下情况：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1和msg2小于TCP的MSS，两个包按照先后顺序被发出，没有被分割和重组</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1过大被分割成两段TCP报文msg1-1、msg2-2进行传送,msg2较小直接被封装成一个报文传送</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1过大被分割成两段TCP报文msg1-1、msg2-2,msg1-1先被传送,剩下的msg1-2和msg2[较小]被组合成一个报文传送</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1过大被分割成两段TCP报文msg1-1、msg2-2,msg1-1先被传送,剩下的msg1-2和msg2[较小]组合起来还是太小,组合的内容在和后面再发送的msg3的前部分数据组合起来发送</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……………………….太多……………………..</p>
<p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接收端[传输层]可能出现的情况</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1,再收到msg2,这种方式太顺利了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1-1，再收到msg1-2，再收到msg2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1，再收到msg2-1,再收到msg2-2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1和msg2-1,再收到msg2-2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //…………还有很多………………</p>
<p>c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实“接收端网络层”接收到的分组数据报顺序和发送端比较可能完全是乱的，比如发“送端网络层”发送1、2、3、4、5，而接收端网络层接收到的数据报顺序却可能是2、1、5、4、3，但是“接收端的传输层”会保证链接的有序性和可靠性，“接收端的传输层”会对“接收端网络层”收到的顺序紊乱的数据报重组成有序的报文[即发送方传输层发出的顺序]，然后交给“接收端应用层”使用，所以“接收端传输层”总是能够保证数据包的有序性，“接收端应用层”[我们编写的socket程序]不用担心接收到的数据的顺序问题。</p>
<p>d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是如上所述，粘包问题和半包问题不可避免。我们在接收端应用层需要自己编码处理粘包和半包问题。一般做法是定义一个缓冲区或者是使用标准库/框架提供的容器循环存放接收到数据，边接收变判断缓冲区数据是否满足包头大小，如果满足包头大小再判断缓冲区剩下数据是否满足包体大小，如果满足则提取。详细步骤如下：</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接收数据存入缓冲区尾部</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区数据满足包头大小否</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区数据不满足包头大小，回到第1步；缓冲区数据满足包头大小则取出包头，接着判断缓冲区剩余数据满足包头中定义的包体大小否，不满足则回到第1步。</p>
<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区数据满足一个包头大小和一个包体大小之和，则取出包头和包体进行使用,此处使用可以采用拷贝方式转移缓冲区数据到另外一个地方，也可以为了节省内存直接采取调用回调函数的方式完成数据使用。</p>
<p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 清除缓冲区的第一个包头和包体信息，做法一般是将缓冲区剩下的数据拷贝到缓冲区首部覆盖“第一个包头和包体信息”部分即可。</p>
<p>粘包、半包处理具体实现很多朋友都有自己的做法，比如最前面贴出的链接，这里我也贴出一段参考：</p>
<p>缓冲区实现头文件：</p>
<p>#include &lt;windows.h&gt;</p>
<p>#ifndef _CNetDataBuffer<em>H</em></p>
<p>#define _CNetDataBuffer<em>H</em></p>
<p>#ifndef TCPLAB_DECLSPEC</p>
<p>#define TCPLAB_DECLSPEC _declspec(dllimport)</p>
<p>#endif</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 数据封包信息定义开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>#pragma pack(push,1)&nbsp;&nbsp; //将原对齐方式压栈,采用新的1字节对齐方式</p>
<p>/<em> 封包类型枚举[此处根据需求列举] </em>/</p>
<p>typedef enum{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NLOGIN=1,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NREG=2,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NBACKUP=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NRESTORE=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NFILE_TRANSFER=4,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NHELLO=5</p>
<p>} PACKETTYPE;</p>
<p>/<em> 包头 </em>/</p>
<p>typedef struct tagNetPacketHead{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte version;//版本</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PACKETTYPE ePType;//包类型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD nLen;//包体长度</p>
<p>} NetPacketHead;</p>
<p>/<em> 封包对象[包头&amp;包体] </em>/</p>
<p>typedef struct tagNetPacket{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacketHead netPacketHead;//包头</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * packetBody;//包体</p>
<p>} NetPacket;</p>
<p>#pragma pack(pop)</p>
<p>/<strong><strong><strong>**</strong></strong></strong>数据封包信息定义结束<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/</p>
<p>//缓冲区初始大小</p>
<p>#define BUFFER_INIT_SIZE 2048 </p>
<p>//缓冲区膨胀系数[缓冲区膨胀后的大小=原大小&#43;系数*新增数据长度]</p>
<p>#define BUFFER_EXPAND_SIZE 2</p>
<p>//计算缓冲区除第一个包头外剩下的数据的长度的宏[缓冲区数据总长度-包头大小]</p>
<p>#define BUFFER_BODY_LEN (m_nOffset-sizeof(NetPacketHead))</p>
<p>//计算缓冲区数据当前是否满足一个完整包数据量[包头&amp;包体]</p>
<p>#define HAS_FULL_PACKET ( \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (sizeof(NetPacketHead)&lt;=m_nOffset) &amp;&amp; \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((((NetPacketHead*)m_pMsgBuffer)-&gt;nLen) &lt;= BUFFER_BODY_LEN) \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )</p>
<p>//检查包是否合法[包体长度大于零且包体不等于空]</p>
<p>#define IS_VALID_PACKET(netPacket) \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((netPacket.netPacketHead.nLen&gt;0) &amp;&amp; (netPacket.packetBody!=NULL))</p>
<p>//缓冲区第一个包的长度</p>
<p>#define FIRST_PACKET_LEN (sizeof(NetPacketHead)&#43;((NetPacketHead*)m_pMsgBuffer)-&gt;nLen)</p>
<p>/<em> 数据缓冲 </em>/</p>
<p>class /<em>TCPLAB_DECLSPEC</em>/ CNetDataBuffer</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 缓冲区操作相关成员 </em>/</p>
<p>private:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *m_pMsgBuffer;//数据缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_nBufferSize;//缓冲区总大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_nOffset;//缓冲区数据大小</p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int GetBufferSize() const;//获得缓冲区的大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL ReBufferSize(int);//调整缓冲区的大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL IsFitPacketHeadSize() const;//缓冲数据是否适合包头大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL IsHasFullPacket() const;//缓冲区是否拥有完整的包数据[包含包头和包体]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL AddMsg(char *pBuf,int nLen);//添加消息到缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *GetBufferContents() const;//得到缓冲区内容</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Reset();//缓冲区复位[清空缓冲区数据,但并未释放缓冲区]</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Poll();//移除缓冲区首部的第一个数据包</p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNetDataBuffer();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~CNetDataBuffer();</p>
<p>};</p>
<p>#endif</p>
<p>缓冲区实现文件:</p>
<p>#define TCPLAB_DECLSPEC _declspec(dllexport)</p>
<p>#include &quot;CNetDataBuffer.h&quot;</p>
<p>/<em> 构造 </em>/</p>
<p>CNetDataBuffer::CNetDataBuffer()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nBufferSize = BUFFER_INIT_SIZE;//设置缓冲区大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset = 0;//设置数据偏移&#20540;[数据大小]为0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = NULL;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = new char[BUFFER_INIT_SIZE];//分配缓冲区为初始大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(m_pMsgBuffer,BUFFER_INIT_SIZE);//缓冲区清空&nbsp;&nbsp;&nbsp; </p>
<p>}</p>
<p>/<em> 析构 </em>/</p>
<p>CNetDataBuffer::~CNetDataBuffer()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_nOffset!=0)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] m_pMsgBuffer;//释放缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = NULL;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nBufferSize=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 获得缓冲区中数据的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区中数据的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>INT CNetDataBuffer::GetBufferSize() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;m_nOffset;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区中的数据大小是否足够一个包头大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/* Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果满足则返回True,否则返回False</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::IsFitPacketHeadSize() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sizeof(NetPacketHead)&lt;=m_nOffset;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 判断缓冲区是否拥有完整的数据包(包头和包体)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果缓冲区包含一个完整封包则返回True,否则False&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::IsHasFullPacket() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果连包头大小都不满足则返回</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (!IsFitPacketHeadSize())</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HAS_FULL_PACKET;//此处采用宏简化代码</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重置缓冲区大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> nLen:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新增加的数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调整结果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::ReBufferSize(int nLen)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *oBuffer = m_pMsgBuffer;//保存原缓冲区地址</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nLen=(nLen&lt;64?64:nLen);//保证最小增量大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //新缓冲区的大小=增加的大小&#43;原缓冲区大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nBufferSize = BUFFER_EXPAND_SIZE*nLen&#43;m_nBufferSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = new char[m_nBufferSize];//分配新的缓冲区,m_pMsgBuff指向新缓冲区地址</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(m_pMsgBuffer,m_nBufferSize);//新缓冲区清零</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory(m_pMsgBuffer,oBuffer,m_nOffset);//将原缓冲区的内容全部拷贝到新缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(…)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete []oBuffer;//释放原缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 向缓冲区添加消息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> pBuf:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要添加的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/* nLen:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 添加的消息长度</p>
<p>/<em> return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 添加成功返回True,否则False&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::AddMsg(char *pBuf,int nLen)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检查缓冲区长度是否满足,不满足则重新调整缓冲区大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_nOffset&#43;nLen&gt;m_nBufferSize)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReBufferSize(nLen);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //拷贝新数据到缓冲区末尾&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory(m_pMsgBuffer&#43;sizeof(char)*m_nOffset,pBuf,nLen);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset&#43;=nLen;//修改数据偏移</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(…)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</p>
<p>}</p>
<p>/<em> 得到缓冲区内容 </em>/</p>
<p>const char * CNetDataBuffer::GetBufferContents() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_pMsgBuffer;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 缓冲区复位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>void CNetDataBuffer::Reset()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_nOffset&gt;0)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset = 0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(m_pMsgBuffer,m_nBufferSize);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 移除缓冲区首部的第一个数据包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>void CNetDataBuffer::Poll()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_nOffset==0 || m_pMsgBuffer==NULL)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IsFitPacketHeadSize() &amp;&amp; HAS_FULL_PACKET)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory(m_pMsgBuffer,m_pMsgBuffer&#43;FIRST_PACKET_LEN*sizeof(char),m_nOffset-FIRST_PACKET_LEN);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>对TCP发包和收包进行简单封装：</p>
<p>头文件：</p>
<p>#include &lt;windows.h&gt;</p>
<p>#include &quot;CNetDataBuffer.h&quot;</p>
<p>// #ifndef TCPLAB_DECLSPEC</p>
<p>// #define TCPLAB_DECLSPEC _declspec(dllimport)</p>
<p>// #endif</p>
<p>#ifndef _CNETCOMTEMPLATE<em>H</em></p>
<p>#define _CNETCOMTEMPLATE<em>H</em></p>
<p>//通信端口</p>
<p>#define TCP_PORT 6000</p>
<p>/<em> 通信终端[包含一个Socket和一个缓冲对象] </em>/</p>
<p>typedef struct {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET m_socket;//通信套接字</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNetDataBuffer m_netDataBuffer;//该套接字关联的数据缓冲区</p>
<p>} ComEndPoint;</p>
<p>/<em> 收包回调函数参数 </em>/</p>
<p>typedef struct{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacket *pPacket;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID processor;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET comSocket;</p>
<p>} PacketHandlerParam;</p>
<p>class CNetComTemplate{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> Socket操作相关成员 </em>/</p>
<p>private:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void SendPacket(SOCKET m_connectedSocket,NetPacket &amp;netPacket);//发包函数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL RecvPacket(ComEndPoint &amp;comEndPoint,void (*recvPacketHandler)(LPVOID)=NULL,LPVOID=NULL);//收包函数</p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNetComTemplate();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~CNetComTemplate();</p>
<p>};</p>
<p>#endif</p>
<p>实现文件：</p>
<p>#include &quot;CNetComTemplate.h&quot;</p>
<p>CNetComTemplate::CNetComTemplate()</p>
<p>{</p>
<p>}</p>
<p>CNetComTemplate::~CNetComTemplate()</p>
<p>{</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:发包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> m_connectedSocket:建立好连接的套接字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> netPacket:要发送的数据包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>void CNetComTemplate::SendPacket(SOCKET m_connectedSocket,NetPacket &amp;netPacket)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_connectedSocket==NULL || !IS_VALID_PACKET(netPacket))//如果尚未建立连接则退出</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::send(m_connectedSocket,(char*)&amp;netPacket.netPacketHead,sizeof(NetPacketHead),0);//先发送包头</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::send(m_connectedSocket,netPacket.packetBody,netPacket.netPacketHead.nLen,0);//在发送包体</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:收包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> comEndPoint:通信终端[包含套接字和关联的缓冲区]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> recvPacketHandler:收包回调函数,当收到一个包后调用该函数进行包的分发处理</em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetComTemplate::RecvPacket(ComEndPoint &amp;comEndPoint,void (*recvPacketHandler)(LPVOID),LPVOID pCallParam)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (comEndPoint.m_socket==NULL)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nRecvedLen = 0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char pBuf[1024];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果缓冲区数据不够包大小则继续从套接字读取tcp报文段</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!(comEndPoint.m_netDataBuffer.IsHasFullPacket()))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nRecvedLen = recv(comEndPoint.m_socket,pBuf,1024,0);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nRecvedLen==SOCKET_ERROR || nRecvedLen==0)//若果Socket错误或者对方连接已经正常关闭则结束读取</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comEndPoint.m_netDataBuffer.AddMsg(pBuf,nRecvedLen);//将新接收的数据存入缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //执行到此处可能是三种情况:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //1.已经读取到的数据满足一个完整的tcp报文段</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //2.读取发生socket_error错误</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //3.在还未正常读取完毕的过程中对方连接已经关闭</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果没有读取到数据或者没有读取到完整报文段则返回返回</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nRecvedLen==0 || (!(comEndPoint.m_netDataBuffer.IsHasFullPacket())))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (recvPacketHandler!=NULL)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造准备传递给回调函数的数据包</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacket netPacket;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netPacket.netPacketHead = <em>(NetPacketHead</em>)comEndPoint.m_netDataBuffer.GetBufferContents();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netPacket.packetBody = new char[netPacket.netPacketHead.nLen];//动态分配包体空间</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造回调函数参数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PacketHandlerParam packetParam;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packetParam.pPacket = &amp;netPacket;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packetParam.processor = pCallParam;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //呼叫回调函数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recvPacketHandler(&amp;packetParam);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete []netPacket.packetBody;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //移除缓冲区的第一个包</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comEndPoint.m_netDataBuffer.Poll();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</p>
<p>}</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2013/6/27 15:14:58 [原文链接](http://blog.csdn.net/kkaxiao/article/details/9188021)
&lt;/div&gt;
&lt;div&gt;
阅读：2216 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/9188021#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/27/转-关于Tcp封包/" data-id="cius3b9hp000bg4ifz8py1bp3" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2013/07/16/转-使用epoll实现客户端UDP并发/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          [转]使用epoll实现客户端UDP并发
        
      </div>
    </a>
  
  
    <a href="/2012/12/29/转-如何在IOS中使用block/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">[转]如何在IOS中使用block</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/02/原-net学习框架/">[原].net学习框架</a>
          </li>
        
          <li>
            <a href="/2013/12/02/转-理解和配置-Linux-下的-OOM-Killer/">[转]理解和配置 Linux 下的 OOM Killer</a>
          </li>
        
          <li>
            <a href="/2013/07/16/转-使用epoll实现客户端UDP并发/">[转]使用epoll实现客户端UDP并发</a>
          </li>
        
          <li>
            <a href="/2013/06/27/转-关于Tcp封包/">[转]关于Tcp封包</a>
          </li>
        
          <li>
            <a href="/2012/12/29/转-如何在IOS中使用block/">[转]如何在IOS中使用block</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Ronger<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>