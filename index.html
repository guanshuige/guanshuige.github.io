<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>观水阁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="观水阁">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="观水阁">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="观水阁">
  
    <link rel="alternate" href="/atom.xml" title="观水阁" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">观水阁</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-原-net学习框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/02/原-net学习框架/" class="article-date">
  <time datetime="2014-12-02T09:42:12.000Z" itemprop="datePublished">2014-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/02/原-net学习框架/">[原].net学习框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><span style="font-family:SimHei; font-size:18px; color:#ff0000">转载本文请务必附上原文连接</span></strong></p>
<p>改定履历</p>
<p>2014/12/02 —————————————新建记录</p>
<p>2014/12/03—————————————-增加Visual studio &quot;扩展与更新的使用如API智能提示扩展 Bing Developer Assistant等及其它网站资源</p>
<p>2014/12/04—————————————–增加若干代码搜索与参考站点</p>
<p>建立学习框架&#43;阅读大量sample源码.</p>
<p>一. 如何建立学习框架</p>
<p>写到这总感觉对这个概念的理解心里清楚但又很难用语言描述出来,不管对不对吧,先写出来,如果后面概念清晰了,再更新嘛;个人理解是这样的,所谓学习框架是在正式开始学习之前先了解一下学习对象的历史\背景,发展概况,目标公司对此有哪一些支撑或利用的资源;以.net为例,微软对.net有哪些支撑?开发者社区,MSDN,各种各样的扩展插件支持,sample等等.所有这些第一手的直接可以用来学习的资源,将对学习有极大帮助.开始了</p>
<p>二. 资源(更新中)</p>
<p>资源介绍这块随着学习的深入会一直更新</p>
<p>1. <a href="http://1code.codeplex.com/releases/view/86101" target="_blank" rel="external"><br>微软发布示例代码浏览器(Sample Browser)</a>&nbsp; 中文详细介绍可能考博客<span style="font-size:14px; font-family:Verdana,'Lucida Grande',Geneva,Arial,sans-serif; letter-spacing:-2px; line-height:18px; outline:none; color:rgb(75,86,152)"><a href="http://www.cnblogs.com/Jialiang/archive/2012/04/17/2453258.html" target="_blank" rel="external">Jialiang’s<br> Blog</a></span></p>
<p>2. visual studio &quot;扩展与更新&quot;的使用</p>
<p><span style="white-space:pre"></span>Visual studio 自身的&quot;Extensions and Updates&quot;功能可以让开发者快速获取需要的扩展插件,比如大家都很熟悉的vc小助手 Visual Assist,有了这些扩展插件,开发效率可以更好的提高;下面具体介绍,以API智能提示扩展<span style="color:rgb(51,51,51); font-family:Georgia,'Times New Roman',Times,sans-serif; font-size:10px; line-height:25.200000762939453px">Bing<br> Developer Assistant为例</span></p>
<p><img src="http://img.blog.csdn.net/20141203114039125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2theGlhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="http://img.blog.csdn.net/20141203114032432?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2theGlhbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如上图所示,打开tools-&gt;Extentions and updates;选择Online在右侧招财进宝框中搜索Bing Developer Assistant,也可模糊搜索,然后下载使用即可;<span style="font-family:Georgia,'Times New Roman',Times,sans-serif; line-height:25.200000762939453px"><span style="font-size:10px; color:#ff6666">有了它，你可以在调用API的同时，方便了解到API的相关示例代码。这大大地有助于开发人员学习和使用API</span></span></p>
<p><span style="font-family:Georgia,'Times New Roman',Times,sans-serif; line-height:25.200000762939453px"><span style="font-size:10px; color:#ff6666"><img src="http://images.cnitblog.com/blog/56838/201409/111427437464869.png" alt="image"></span></span></p>
<p></p>
<p><span style="color:#ff6666">当然,有大量其它扩展应用可以使用,等待着你去发现.</span></p>
<p><span style="color:#ff6666"></span></p>
<p></p>
<p>3. 网站资源:</p>
<p>1. <a href="http://www.codeplex.com/" target="_blank" rel="external">CodePlex</a>&nbsp;前面介绍的code browser即从此网站下载,该网站拥有大量相关资源,不可错过</p>
<p>2. 代码搜索及参考站点</p>
<p><a href="https://searchcode.com/" target="_blank" rel="external">searchcode</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br><a href="http://www.codase.com/" target="_blank" rel="external">codase</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br><a href="http://4coder.org/" target="_blank" rel="external">&nbsp;4cpder</a></p>
<p><a href="http://www.codeproject.com/" target="_blank" rel="external">&nbsp;codeProject</a></p>
<p>4. 微软提供的资源</p>
<p><a href="http://msdn.microsoft.com/zh-cn/vstudio/aa718325.aspx" target="_blank" rel="external">visual studio主页</a>&nbsp;: 提供大量visual studio 资讯</p>
<p><a href="http://msdn.microsoft.com/zh-cn/vstudio/aa718325.aspx" target="_blank" rel="external">示例</a>&nbsp;: 提供大量基于桌面,web等各平台的示例,方便检索</p>
<p><a href="http://msdn.microsoft.com/zh-cn/vstudio/jj672990.aspx" target="_blank" rel="external">语言</a>&nbsp;:&nbsp;<span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px">查找学习<br> Visual Studio 语言并使用此语言构建所需应用程序所需的资源</span></span></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"><a href="https://visualstudiogallery.msdn.microsoft.com/" target="_blank" rel="external">扩展</a>&nbsp;:<br> 罗列大量vs插件</span></span></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"><a href="http://msdn.microsoft.com/library/vstudio" target="_blank" rel="external">文档</a>&nbsp;:<br> 开发文档</span></span></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"><a href="https://social.msdn.microsoft.com/forums/vstudio/zh-cn/home" target="_blank" rel="external">论坛</a><br> : 开发者论坛,.net之家</span></span></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"></span></span></p>
<p></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px">5. 使用&quot;每日一例&quot;</span></span></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"><span style="color:rgb(51,51,51); font-family:Georgia,'Times New Roman',Times,sans-serif; line-height:25.200000762939453px"><span style="white-space:pre"></span>微软一站式示例代码库发布“</span><span style="color:rgb(51,51,51); font-family:Georgia,'Times New Roman',Times,sans-serif; line-height:25.200000762939453px">每日一例</span><span style="color:rgb(51,51,51); font-family:Georgia,'Times New Roman',Times,sans-serif; line-height:25.200000762939453px">”。每日分享一个经典示例代码，希望能够帮助那些对各种技术感兴趣的开发人员每天积累一些新的开发知识。所有分享的示例代码都来源于全球开发人员最常用到的编程场景;RSS订阅:&nbsp;<a href="http://blogs.msdn.com/b/codefx/rss.aspx?tags=SampleOfTheDay" target="_blank" rel="external">http://blogs.msdn.com/b/codefx/rss.aspx?tags=SampleOfTheDay</a></span></span></span></p>
<p></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"></span></span></p>
<p></p>
<p><span style="font-family:'Microsoft YaHei UI','Microsoft YaHei',SimSun,'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; line-height:18.200000762939453px"><span style="font-size:10px"></span></span></p>
<p></p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2014/12/2 17:42:12 [原文链接](http://blog.csdn.net/kkaxiao/article/details/41680555)
&lt;/div&gt;
&lt;div&gt;
阅读：458 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/41680555#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/02/原-net学习框架/" data-id="cius3b9hk000ag4ifistxsq6c" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-理解和配置-Linux-下的-OOM-Killer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/02/转-理解和配置-Linux-下的-OOM-Killer/" class="article-date">
  <time datetime="2013-12-02T07:06:35.000Z" itemprop="datePublished">2013-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/02/转-理解和配置-Linux-下的-OOM-Killer/">[转]理解和配置 Linux 下的 OOM Killer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近有位 VPS 客户抱怨 MySQL 无缘无故挂掉，还有位客户抱怨 VPS 经常死机，登陆到终端看了一下，都是常见的 Out of memory 问题。这通常是因为某时刻应用程序大量请求内存导致系统内存不足造成的，这通常会触发 Linux 内核里的 Out of Memory (OOM) killer，OOM killer 会杀掉某个进程以腾出内存留给系统用，不致于让系统立刻崩溃。如果检查相关的日志文件（/var/log/messages）就会看到下面类&#20284;的 Out of memory: Kill process<br> 信息：</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_1_1008226" class="html" name="code">...
Out of memory: Kill process 9682 (mysqld) score 9 or sacrifice child
Killed process 9682, UID 27, (mysqld) total-vm:47388kB, anon-rss:3744kB, file-rss:80kB
httpd invoked oom-killer: gfp_mask=0x201da, order=0, oom_adj=0, oom_score_adj=0
httpd cpuset=/ mems_allowed=0
Pid: 8911, comm: httpd Not tainted 2.6.32-279.1.1.el6.i686 #1
...
21556 total pagecache pages
21049 pages in swap cache
Swap cache stats: add 12819103, delete 12798054, find 3188096/4634617
Free swap  = 0kB
Total swap = 524280kB
131071 pages RAM
0 pages HighMem
3673 pages reserved
67960 pages shared
124940 pages non-shared
</pre></pre>

<p>Linux 内核根据应用程序的要求分配内存，通常来说应用程序分配了内存但是并没有实际全部使用，为了提高性能，这部分没用的内存可以留作它用，这部分内存是属于每个进程的，内核直接回收利用的话比较麻烦，所以内核采用一种过度分配内存（over-commit memory）的办法来间接利用这部分 “空闲” 的内存，提高整体内存的使用效率。一般来说这样做没有问题，但当大多数应用程序都消耗完自己的内存的时候麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。用银行的例子来讲可能更容易懂一些，部分人取钱的时候银行不怕，银行有足够的存款应付，当全国人民（或者绝大多数）都取钱而且每个人都想把自己钱取完的时候银行的麻烦就来了，银行实际上是没有这么多钱给大家取的。</p>
<p>内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码 <a href="https://github.com/torvalds/linux/blob/master/mm/oom_kill.c" target="_blank" rel="external"><br>linux/mm/oom_kill.c</a>，当系统内存不足的时候，out_of_memory() 被触发，然后调用 select_bad_process() 选择一个 “bad” 进程杀掉，如何判断和选择一个 “bad” 进程呢，总不能随机选吧？挑选的过程由 oom_badness() 决定，挑选的算法和想法都很简单很朴实：最 bad 的那个进程就是那个最占用内存的进程。</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_2_5500565" class="cpp" name="code">/**
 * oom_badness - heuristic function to determine which candidate task to kill
 * @p: task struct of which task we should calculate
 * @totalpages: total present RAM allowed for page allocation
 *
 * The heuristic for determining which task to kill is made to be as simple and
 * predictable as possible.  The goal is to return the highest value for the
 * task consuming the most memory to avoid subsequent oom failures.
 */
unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *memcg,
              const nodemask_t *nodemask, unsigned long totalpages)
{
    long points;
    long adj;

    if (oom_unkillable_task(p, memcg, nodemask))
        return 0;

    p = find_lock_task_mm(p);
    if (!p)
        return 0;

    adj = (long)p-&gt;signal-&gt;oom_score_adj;
    if (adj == OOM_SCORE_ADJ_MIN) {
        task_unlock(p);
        return 0;
    }

    /*
     * The baseline for the badness score is the proportion of RAM that each
     * task's rss, pagetable and swap space use.
     */
    points = get_mm_rss(p-&gt;mm) + p-&gt;mm-&gt;nr_ptes +
         get_mm_counter(p-&gt;mm, MM_SWAPENTS);
    task_unlock(p);

    /*
     * Root processes get 3% bonus, just like the __vm_enough_memory()
     * implementation used by LSMs.
     */
    if (has_capability_noaudit(p, CAP_SYS_ADMIN))
        adj -= 30;

    /* Normalize to oom_score_adj units */
    adj *= totalpages / 1000;
    points += adj;

    /*
     * Never return 0 for an eligible task regardless of the root bonus and
     * oom_score_adj (oom_score_adj can't be OOM_SCORE_ADJ_MIN here).
     */
    return points &gt; 0 ? points : 1;
}
</pre>
</pre>

<p>上面代码里的注释写的很明白，理解了这个算法我们就理解了为啥 MySQL 躺着也能中枪了，因为它的体积总是最大（一般来说它在系统上占用内存最多），所以如果 Out of Memeory (OOM) 的话总是不幸第一个被 kill 掉。解决这个问题最简单的办法就是增加内存，或者<a href="http://www.vpsee.com/2009/06/64mb-vps-optimize-mysql/" target="_blank" rel="external">想办法优化 MySQL 使其占用更少的内存</a>，除了优化<br> MySQL 外还可以优化系统（<a href="http://www.vpsee.com/2009/06/64mb-vps-optimize-debian5/" target="_blank" rel="external">优化 Debian 5</a>，<a href="http://www.vpsee.com/2009/06/128mb-vps-optimize-centos5/" target="_blank" rel="external">优化 CentOS 5.x</a>），让系统尽可能使用少的内存以便应用程序（如<br> MySQL) 能使用更多的内存，还有一个临时的办法就是调整内核参数，让 MySQL 进程不容易被 OOM killer 发现。</p>
<h1 id="配置-OOM-killer"><a href="#配置-OOM-killer" class="headerlink" title="配置 OOM killer"></a>配置 OOM killer</h1><p>我们可以通过一些内核参数来调整 OOM killer 的行为，避免系统在那里不停的杀进程。比如我们可以在触发 OOM 后立刻触发 kernel panic，kernel panic 10秒后自动重启系统。</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_3_8192435" class="cpp" name="code"># sysctl -w vm.panic_on_oom=1
vm.panic_on_oom = 1

# sysctl -w kernel.panic=10
kernel.panic = 10

# echo &quot;vm.panic_on_oom=1&quot; &gt;&gt; /etc/sysctl.conf
# echo &quot;kernel.panic=10&quot; &gt;&gt; /etc/sysctl.conf
</pre>
</pre>

<p>从上面的 oom_kill.c 代码里可以看到 oom_badness() 给每个进程打分，根据 points 的高低来决定杀哪个进程，这个 points 可以根据 adj 调节，root 权限的进程通常被认为很重要，不应该被轻易杀掉，所以打分的时候可以得到 3% 的优惠（adj -= 30; 分数越低越不容易被杀掉）。我们可以在用户空间通过操作每个进程的 oom_adj 内核参数来决定哪些进程不这么容易被 OOM killer 选中杀掉。比如，如果不想 MySQL 进程被轻易杀掉的话可以找到 MySQL<br> 运行的进程号后，调整 oom_score_adj 为 -15（注意 points 越小越不容易被杀）：</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_4_1987447" class="cpp" name="code"># ps aux | grep mysqld
mysql    2196  1.6  2.1 623800 44876 ?        Ssl  09:42   0:00 /usr/sbin/mysqld

# cat /proc/2196/oom_score_adj
0
# echo -15 &gt; /proc/2196/oom_score_adj
</pre>
</pre>

<p>当然，如果需要的话可以完全关闭 OOM killer（不推荐用在生产环境）：</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_5_3241183" class="cpp" name="code"># sysctl -w vm.overcommit_memory=2

# echo &quot;vm.overcommit_memory=2&quot; &gt;&gt; /etc/sysctl.conf
</pre></pre>

<h1 id="找出最有可能被-OOM-Killer-杀掉的进程"><a href="#找出最有可能被-OOM-Killer-杀掉的进程" class="headerlink" title="找出最有可能被 OOM Killer 杀掉的进程"></a>找出最有可能被 OOM Killer 杀掉的进程</h1><p>我们知道了在用户空间可以通过操作每个进程的 oom_adj 内核参数来调整进程的分数，这个分数也可以通过 oom_score 这个内核参数看到，比如查看进程号为981的 omm_score，这个分数被上面提到的 omm_score_adj 参数调整后（－15），就变成了3：</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_6_2019684" class="cpp" name="code"># cat /proc/981/oom_score
18

# echo -15 &gt; /proc/981/oom_score_adj
# cat /proc/981/oom_score
3
</pre>
</pre>

<p>下面这个 bash 脚本可用来打印当前系统上 oom_score 分数最高（最容易被 OOM Killer 杀掉）的进程：</p>
<pre class="code"><pre code_snippet_id="92236" snippet_file_name="blog_20131202_7_2401368" class="cpp" name="code"># vi oomscore.sh
#!/bin/bash
for proc in $(find /proc -maxdepth 1 -regex '/proc/[0-9]+'); do
    printf &quot;%2d %5d %s\n&quot; \
        &quot;$(cat $proc/oom_score)&quot; \
        &quot;$(basename $proc)&quot; \
        &quot;$(cat $proc/cmdline | tr '\0' ' ' | head -c 50)&quot;
done 2&gt;/dev/null | sort -nr | head -n 10

# chmod +x oomscore.sh
# ./oomscore.sh
18   981 /usr/sbin/mysqld
 4 31359 -bash
 4 31056 -bash
 1 31358 sshd: root@pts/6
 1 31244 sshd: vpsee [priv]
 1 31159 -bash
 1 31158 sudo -i
 1 31055 sshd: root@pts/3
 1 30912 sshd: vpsee [priv]
 1 29547 /usr/sbin/sshd -D
</pre></pre>

<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2013/12/2 15:06:35 [原文链接](http://blog.csdn.net/kkaxiao/article/details/17073809)
&lt;/div&gt;
&lt;div&gt;
阅读：364 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/17073809#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/02/转-理解和配置-Linux-下的-OOM-Killer/" data-id="cius3b9hh0008g4ifny7is7vh" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-使用epoll实现客户端UDP并发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/07/16/转-使用epoll实现客户端UDP并发/" class="article-date">
  <time datetime="2013-07-16T12:48:36.000Z" itemprop="datePublished">2013-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/16/转-使用epoll实现客户端UDP并发/">[转]使用epoll实现客户端UDP并发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>g&#43;&#43; -o&nbsp; udp_epoll_c udp_epoll_c.cpp -lpthread</p>
<pre class="cpp" name="code">/***************************************************************************
                file:   udp_epoll_c.cpp
               -------------------
     begin                : 2006/01/17
     copyright            : (C) 2005 by 张荐林
     email                : zhangjianlin_8 at 126.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include &lt;errno.h&gt;
 #include &lt;iostream&gt;
 #include &lt;sys/socket.h&gt;
 #include &lt;sys/epoll.h&gt;
 #include &lt;netinet/in.h&gt;
 #include &lt;arpa/inet.h&gt;
 #include &lt;sys/socket.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;netinet/in.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;string&gt;
 #include &lt;sys/resource.h&gt;
 #include &lt;pthread.h&gt;
 #include &lt;vector&gt;
 using namespace std;
 int Read(int fd,void *buffer,unsigned int length) 
{ 
unsigned int nleft;
 int nread;
 char *ptr;
 ptr = (char *)buffer;
 nleft = length;
 while(nleft &gt; 0)
 {
   if((nread = read(fd, ptr, nleft))&lt; 0)
   {
    if(errno == EINTR)
     nread = 0;
    else
     return -1;
   }
   else if(nread == 0)
   {
    break;
   }
   nleft -= nread;
   ptr += nread;
 }
 return length - nleft;
 } 

int Write(int fd,const void *buffer,unsigned int length) 
{ 
unsigned int nleft;
 int nwritten;
 const char *ptr;
 ptr = (const char *)buffer;
 nleft = length;
 while(nleft &gt; 0)
 {
   if((nwritten = write(fd, ptr, nleft))&lt;=0)
   {
    if(errno == EINTR)
     nwritten=0;
    else
     return -1;
   }
   nleft -= nwritten;
   ptr += nwritten;
 }
 return length;
 } 
int CreateThread(void *(*start_routine)(void *), void *arg = NULL, pthread_t *thread = NULL, pthread_attr_t *pAttr = NULL)
 {
 pthread_attr_t thr_attr;
 if(pAttr == NULL)
 {
   pAttr = &amp;thr_attr;
   pthread_attr_init(pAttr);
   pthread_attr_setstacksize(pAttr, 1024 * 1024);  // 1 M的堆栈
    pthread_attr_setdetachstate(pAttr,  PTHREAD_CREATE_DETACHED);
 }
 pthread_t tid;
 if(thread == NULL)
 {
   thread = &amp;tid;
 }
 int r = pthread_create(thread, pAttr, start_routine, arg);
 pthread_attr_destroy(pAttr);
 return r;
 }

static int SetRLimit()
 {
 struct rlimit rlim;
 rlim.rlim_cur = 20480;
 rlim.rlim_max = 20480;
 if (setrlimit(RLIMIT_NOFILE, &amp;rlim) != 0)
 {
   perror(&quot;setrlimit&quot;);
 }
 else
 {
   printf(&quot;setrlimit ok/n&quot;);
 }
 return 0;
 }

int setnonblocking(int sock)
 {
 int opts;
 opts=fcntl(sock,F_GETFL);
 if(opts&lt;0)
 {
   return -1;
 }
 opts = opts|O_NONBLOCK;
 if(fcntl(sock,F_SETFL,opts)&lt;0)
 {
   return -1;
 }    
return 0;
 }

int ConnectToUdperver(const char *host, unsigned short port)
 {
 int sock = socket(AF_INET, SOCK_DGRAM, 0);
 if(sock &lt; 0)
 {
   perror(&quot;socket&quot;);
         return -1;
 }
 struct sockaddr_in addr;
 memset(&amp;addr, 0, sizeof(addr));
 addr.sin_family = AF_INET;
 addr.sin_port = htons(port);
 addr.sin_addr.s_addr = inet_addr(host);

if(connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0)
 {
   perror(&quot;bind&quot;);
   close(sock);
      return -1;
 }
 return sock;
 }

void *SendThread(void *arg)
 {
 vector&lt;int&gt; sockets;
 sockets = *((vector&lt;int&gt; *)arg);

int n = 0;
 char data[1024];
 int i = 0;
 while(1)
 {
   for(vector&lt;int&gt;::iterator itr = sockets.begin(), last = sockets.end(); itr != last; ++itr)
   {
    sprintf(data, &quot;test data %d/n&quot;, i++);
    n = Write(*itr, &quot;hello&quot;, 5);
    printf(&quot;socket %d write to server[ret = %d]:%s&quot;,*itr, n, data);  
   }
   sleep(1);
 }
 }

int main(int argc, char **argv)
 {
 SetRLimit();
 printf(&quot;FD_SETSIZE= %d/n&quot;, FD_SETSIZE);
 if (argc != 3)
 {
   printf(&quot;usage: %s &lt;IPaddress&gt; &lt;PORT&gt;/n&quot;, argv[0]);
   return 1;
 }

int epfd = epoll_create(20480);
 if(epfd &lt; 0)
 {
   perror(&quot;epoll_create&quot;);
   return 1;
 }
 struct epoll_event event;
 struct epoll_event ev[20480];
 vector&lt;int&gt; sockets;
 for(int i = 0; i &lt; 3000; i++)
 {
   int sockfd = ConnectToUdperver(argv[1], (unsigned short)(atoi(argv[2])));
   if(sockfd &lt; 0)
   {
    printf(&quot;Cannot connect udp server %s %s/n&quot;, argv[1], argv[2]);
    return 1;
   }

   sockets.push_back(sockfd);
   setnonblocking(sockfd);
   event.data.fd = sockfd;
      event.events = EPOLLIN|EPOLLET;
      if(0 != epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;event))
   {
    perror(&quot;epoll_ctl&quot;);
   }
 }
 if(0 != CreateThread(SendThread, (void *)&amp;sockets))
 {
   perror(&quot;CreateThread&quot;);
   return 2;
 }
 int nfds = 0;  
 while(1)
 {
         nfds=epoll_wait(epfd,ev,20480,500);
   if(nfds &lt; 0)
   {
    perror(&quot;epoll_wait&quot;);
    break;
   }
   else if(nfds == 0)
   {
    printf(&quot;epoll_wait timeout!/n&quot;);
    continue;
   }
   for(int i = 0; i &lt; nfds; i++)
   {
    if(ev[i].events &amp; EPOLLIN)
    {
     printf(&quot;can read for %d now/n&quot;, ev[i].data.fd);
     char data[1024] = {0};
     int n = read(ev[i].data.fd, data, sizeof(data));
     printf(&quot;Received %d bytes from server!/n&quot;, n);
    }
   }
 }
 for(vector&lt;int&gt;::iterator itr = sockets.begin(), last = sockets.end(); itr != last; itr++)
 {
   close(*itr);
 }
 close(epfd);
 return 0;
 }</pre>

<p>&nbsp;</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2013/7/16 20:48:36 [原文链接](http://blog.csdn.net/kkaxiao/article/details/9346753)
&lt;/div&gt;
&lt;div&gt;
阅读：427 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/9346753#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/07/16/转-使用epoll实现客户端UDP并发/" data-id="cius3b9h10004g4if6do8fufk" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-关于Tcp封包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/06/27/转-关于Tcp封包/" class="article-date">
  <time datetime="2013-06-27T07:14:58.000Z" itemprop="datePublished">2013-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/06/27/转-关于Tcp封包/">[转]关于Tcp封包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>写的很优秀的一篇文章,转过来给大家看一下,转自<a href="http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html" target="_blank" rel="external">http://www.cnblogs.com/jiangtong/archive/2012/03/22/2411985.html</a>.感谢博主辛苦原创</p>
<p>很多朋友已经对此作了不少研究，也花费不少心血编写了实现代码和blog文档。当然也充斥着一些各式的评论，自己看了一下，总结一些心得。</p>
<p>首先我们学习一下这些朋友的心得，他们是：</p>
<p><a href="http://blog.csdn.net/stamhe/article/details/4569530" target="_blank" rel="external">http://blog.csdn.net/stamhe/article/details/4569530</a></p>
<p><a href="http://www.cppblog.com/tx7do/archive/2011/05/04/145699.html" target="_blank" rel="external">http://www.cppblog.com/tx7do/archive/2011/05/04/145699.html</a></p>
<p>//………………</p>
<p>当然还有太多，很多东西粘来粘区也不知道到底是谁的原作,J</p>
<p>看这些朋友的blog是我建议亲自看一下TCP-IP详解卷1中的相关内容【原理性的内容一定要看】。</p>
<h2 id="TCP大致工作原理介绍："><a href="#TCP大致工作原理介绍：" class="headerlink" title="TCP大致工作原理介绍："></a>TCP大致工作原理介绍：</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>TCP-IP详解卷1第17章中17.2节对TCP服务原理作了一个简明介绍(以下蓝色字体摘自《TCP-IP详解卷1第17章17.2节》)：</p>
<p><span style="color:#3366ff">尽管</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">都使用相同的网络层（</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">），</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">却向应用层提供与</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">完全不同的服务。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">提供一种面向连接的、可靠的字节流服务。</span></p>
<p><span style="color:#3366ff">面向连接意味着两个使用</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接。这一过程与打电话很相&#20284;，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。在第</span><span style="color:#3366ff">1<br> 8</span><span style="color:#3366ff">章我们将看到一个</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接是如何建立的，以及当一方通信结束后如何断开连接。</span></p>
<p><span style="color:#3366ff">在一个</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接中，仅有两方进行彼此通信。在第</span><span style="color:#3366ff">1 2</span><span style="color:#3366ff">章介绍的广播和多播不能用于</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">T C P</span><span style="color:#3366ff">通过下列方式来提供可靠性：</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">应用数据被分割成</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">认为最适合发送的数据块。这和</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">完全不同，应用程序产生的数据报长度将保持不变。由</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">传递给</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">的信息单位称为报文段或段（</span><span style="color:#3366ff">s e g m e n t</span><span style="color:#3366ff">）（参见图</span><span style="color:#3366ff">1 - 7</span><span style="color:#3366ff">）。在</span><span style="color:#3366ff">1<br> 8 . 4</span><span style="color:#3366ff">节我们将看到</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">如何确定报文段的长度。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">当</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。在第</span><span style="color:#3366ff">2 1</span><span style="color:#3366ff">章我们将了解</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">协议中自适应的超时及重传策略。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">当</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">收到发自</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒，这将在</span><span style="color:#3366ff">1<br> 9 . 3</span><span style="color:#3366ff">节讨论。</span></p>
<p><span style="color:#3366ff">• T C P</span><span style="color:#3366ff">将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">既然</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">报文段作为</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报来传输，而</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">数据报的到达可能会失序，因此</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">报文段的到达也可能会失序。如果必要，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</span></p>
<p><span style="color:#3366ff">• </span><span style="color:#3366ff">既然</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报会发生重复，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">的接收端必须丢弃重复的数据。</span></p>
<p><span style="color:#3366ff">• T C P</span><span style="color:#3366ff">还能提供流量控制。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接的每一方都有固定大小的缓冲空间。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。两个应用程序通过</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">连接交换</span><span style="color:#3366ff">8 bit</span><span style="color:#3366ff">字节构成的字节流。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">不在字节流中插入记录标识符。我们将这称为字节流服务（</span><span style="color:#3366ff">byte<br> stream service</span><span style="color:#3366ff">）。如果一方的应用程序先传</span><span style="color:#3366ff">1 0</span><span style="color:#3366ff">字节，又传</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节，再传</span><span style="color:#3366ff">5 0</span><span style="color:#3366ff">字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分</span><span style="color:#3366ff">4</span><span style="color:#3366ff">次接收这</span><span style="color:#3366ff">8<br> 0</span><span style="color:#3366ff">个字节，每次接收</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节。一端将字节流放到</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接上，同样的字节流将出现在</span><span style="color:#3366ff">T C<br> P</span><span style="color:#3366ff">连接的另一端。另外，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">对字节流的内容不作任何解释。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">不知道传输的数据字节流是二进制数据，还是</span><span style="color:#3366ff">A<br> S C I I</span><span style="color:#3366ff">字符、</span><span style="color:#3366ff">E B C D I C</span><span style="color:#3366ff">字符或者其他类型数据。对字节流的解释由</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">连接双方的应用层解释。这种对字节流的处理方式与</span><span style="color:#3366ff">U<br> n i x</span><span style="color:#3366ff">操作系统对文件的处理方式很相&#20284;。</span><span style="color:#3366ff">U n i x</span><span style="color:#3366ff">的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对</span><span style="color:#3366ff">U n i x</span><span style="color:#3366ff">的内核来说，它无法区分一个二进制文件与一个文本文件。</span></p>
<h3 id="T-C-P如何确定报文段的长度"><a href="#T-C-P如何确定报文段的长度" class="headerlink" title="T C P如何确定报文段的长度"></a>T C P如何确定报文段的长度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我仍然引用官方解释《TCP-IP详解卷1》第18章18.4节：</p>
<p><span style="color:#3366ff">最大报文段长度（ </span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">）表示</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">传往另一端的最大块数据的长度。当一个连接建立时【三次握手】，连接的双方都要通告各自的</span><span style="color:#3366ff">M<br> S S</span><span style="color:#3366ff">。我们已经见过</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">都是</span><span style="color:#3366ff">1 0 2 4</span><span style="color:#3366ff">。这导致</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报通常是</span><span style="color:#3366ff">4<br> 0</span><span style="color:#3366ff">字节长：</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部和</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">首部。</span></p>
<p><span style="color:#3366ff">在有些书中，将它看作可“协商”选项。它并不是任何条件下都可协商。当建立一个连</span></p>
<p><span style="color:#3366ff">接时，每一方都有用于通告它期望接收的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">选项（</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">选项只能出现在</span><span style="color:#3366ff">S<br> Y N</span><span style="color:#3366ff">报文段中）。如果一方不接收来自另一方的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">&#20540;，则</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">就定为默认&#20540;</span><span style="color:#3366ff">5 3 6</span><span style="color:#3366ff">字节（这个默认&#20540;允许</span><span style="color:#3366ff">2<br> 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">首部和</span><span style="color:#3366ff">2 0</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部以适合</span><span style="color:#3366ff">5<br> 7 6</span><span style="color:#3366ff">字节</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">数据报</span><span style="color:#3366ff">)</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">一般说来，如果没有分段发生， </span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">还是越大越好（这也并不总是正确，参见图</span><span style="color:#3366ff">2 4 - 3</span><span style="color:#3366ff">和图</span><span style="color:#3366ff">2<br> 4 - 4</span><span style="color:#3366ff">中的例子）。报文段越大允许每个报文段传送的数据就越多，相对</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部有更高的网络利用率。当</span><span style="color:#3366ff">T<br> C P</span><span style="color:#3366ff">发送一个</span><span style="color:#3366ff">S Y N</span><span style="color:#3366ff">时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它能将</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">&#20540;设置为外出接口上的</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">长度减去固定的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">首部和</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">首部长度。对于一个以太网，</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">&#20540;可达</span><span style="color:#3366ff">1<br> 4 6 0</span><span style="color:#3366ff">字节。使用</span><span style="color:#3366ff">IEEE 802.3</span><span style="color:#3366ff">的封装（参见</span><span style="color:#3366ff">2 . 2</span><span style="color:#3366ff">节），它的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">可达</span><span style="color:#3366ff">1<br> 4 5 2</span><span style="color:#3366ff">字节。</span></p>
<p><span style="color:#3366ff">如果目的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">地址为“非本地的</span><span style="color:#3366ff">( n o n l o c a l )</span><span style="color:#3366ff">”，</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">通常的默认&#20540;为</span><span style="color:#3366ff">5<br> 3 6</span><span style="color:#3366ff">。而区分地址是本地还是非本地是简单的，如果目的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">地址的网络号与子网号都和我们的相同，则是本地的；如果目的</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">地址的网络号与我们的完全不同，则是非本地的；如果目的</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。大多数</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">实现版都提供了一个配置选项（附录</span><span style="color:#3366ff">E</span><span style="color:#3366ff">和图</span><span style="color:#3366ff">E</span></p>
<ul>
<li>1<span style="color:#3366ff">），让系统管理员说明不同的子网是属于本地还是非本地。这个选项的设置将确定</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">可以选择尽可能的大（达到外出接口的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">长度）或是默认&#20540;</span><span style="color:#3366ff">5<br>3 6</span><span style="color:#3366ff">。</span></li>
</ul>
<p><span style="color:#3366ff">M S S</span><span style="color:#3366ff">让主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这将使以较小</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">连接到一个网络上的主机避免分段。</span></p>
<p><span style="color:#3366ff">只有当一端的主机以小于</span><span style="color:#3366ff">5 7 6</span><span style="color:#3366ff">字节的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">直接连接到一个网络中，避免这种分段才会有效。</span></p>
<p><span style="color:#3366ff">如果两端的主机都连接到以太网上，都采用</span><span style="color:#3366ff">5 3 6</span><span style="color:#3366ff">的</span><span style="color:#3366ff">M S S</span><span style="color:#3366ff">，但中间网络采用</span><span style="color:#3366ff">2 9 6</span><span style="color:#3366ff">的</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">，也将会</span></p>
<p><span style="color:#3366ff">出现分段。使用路径上的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">发现机制（参见</span><span style="color:#3366ff">2 4 . 2</span><span style="color:#3366ff">节）是关于这个问题的唯一方法。</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以上说明MSS的&#20540;可以通过协商解决，这个协商过程会涉及MTU的&#20540;的大小，前面说了：【MSS=外出接口上的MTU-IP首部-TCP首部】，我们来看看数据进入TCP协议栈的封装过程：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733115740.jpg" target="_blank" rel="external"><br><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733121496.jpg" alt="clip_image002" title="clip_image002"></a></p>
<p>最后一层以太网帧的大小应该就是我们的出口ＭＴＵ大小了。当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（ D e m u l t i p l e x i n g），图1 - 8显示了该过程是如何发生的。</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733178493.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733185885.jpg" alt="clip_image004" title="clip_image004"></a></p>
<p>那么什么是MTU呢，这实际上是数据链路层的一个概念，以太网和802.3这两种局域网技术标准都对“链路层”的数据帧有大小限制：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733203735.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733224094.jpg" alt="clip_image006" title="clip_image006"></a></p>
<p><span style="color:#3366ff">l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3366ff">最大传输单元</span><span style="color:#3366ff">MTU</span></p>
<p><span style="color:#3366ff">正如在图</span><span style="color:#3366ff">2 - 1</span><span style="color:#3366ff">看到的那样，以太网和</span><span style="color:#3366ff">8 0 2 . 3</span><span style="color:#3366ff">对数据帧的长度都有一个限制，其最大&#20540;分别是</span><span style="color:#3366ff">1<br> 5 0 0</span><span style="color:#3366ff">和</span><span style="color:#3366ff">1 4 9 2</span><span style="color:#3366ff">字节。链路层的这个特性称作</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">，最大传输单元。不同类型的网络大多数都有一个上限。</span></p>
<p><span style="color:#3366ff">如果</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">层有一个数据报要传，而且数据的长度比链路层的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">还大，那么</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">层就需要进行分片（</span><span style="color:#3366ff"><br> f r a g m e n t a t i o n</span><span style="color:#3366ff">），把数据报分成若干片，这样每一片都小于</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。我们将在</span><span style="color:#3366ff">11 . 5</span><span style="color:#3366ff">节讨论</span><span style="color:#3366ff">I<br> P</span><span style="color:#3366ff">分片的过程。</span></p>
<p><span style="color:#3366ff">图</span><span style="color:#3366ff">2 - 5</span><span style="color:#3366ff">列出了一些典型的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">&#20540;，它们摘自</span><span style="color:#3366ff">RFC 1191[Mogul and Deering<br> 1990]</span><span style="color:#3366ff">。点到点的链路层（如</span><span style="color:#3366ff">S L I P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">P P P</span><span style="color:#3366ff">）的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">并非指的是网络媒体的物理特性。相反，它是一个逻辑限制，目的是为交互使用提供足够快的响应时间。在</span><span style="color:#3366ff">2<br> . 1 0</span><span style="color:#3366ff">节中，我们将看到这个限制&#20540;是如何计算出来的。在</span><span style="color:#3366ff">3 . 9</span><span style="color:#3366ff">节中，我们将用</span><span style="color:#3366ff">n e t s t a t</span><span style="color:#3366ff">命令打印出网络接口的</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3366ff">路径</span><span style="color:#3366ff">MTU</span></p>
<p><span style="color:#3366ff">当在同一个网络上的两台主机互相进行通信时，该网络的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">是非常重要的。但是如果</span></p>
<p><span style="color:#3366ff">两台主机之间的通信要通过多个网络，那么每个网络的链路层就可能有不同的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。重要的</span></p>
<p><span style="color:#3366ff">不是两台主机所在网络的</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的&#20540;，重要的是两台通信主机路径中的最小</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。它被称作路</span></p>
<p><span style="color:#3366ff">径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">两台主机之间的路径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">不一定是个常数。它取决于当时所选择的路由。而选路不一定</span></p>
<p><span style="color:#3366ff">是对称的（从</span><span style="color:#3366ff">A</span><span style="color:#3366ff">到</span><span style="color:#3366ff">B</span><span style="color:#3366ff">的路由可能与从</span><span style="color:#3366ff">B</span><span style="color:#3366ff">到</span><span style="color:#3366ff">A</span><span style="color:#3366ff">的路由不同），因此路径</span><span style="color:#3366ff">M<br> T U</span><span style="color:#3366ff">在两个方向上不一定是</span></p>
<p><span style="color:#3366ff">一致的。</span></p>
<p><span style="color:#3366ff">RFC 1191[Mogul and Deering 1990]</span><span style="color:#3366ff">描述了路径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的发现机制，即在任何时候确定路径</span></p>
<p><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的方法。我们在介绍了</span><span style="color:#3366ff">I C M P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">I P</span><span style="color:#3366ff">分片方法以后再来看它是如何操作的。在</span><span style="color:#3366ff">11<br> . 6</span><span style="color:#3366ff">节中，我</span></p>
<p><span style="color:#3366ff">们将看到</span><span style="color:#3366ff">I C M P</span><span style="color:#3366ff">的不可到达错误就采用这种发现方法。在</span><span style="color:#3366ff">11 . 7</span><span style="color:#3366ff">节中，还会看到，</span><span style="color:#3366ff"> t r a c<br> e r o u t e</span><span style="color:#3366ff">程序</span></p>
<p><span style="color:#3366ff">也是用这个方法来确定到达目的节点的路径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">。在</span><span style="color:#3366ff">11 . 8</span><span style="color:#3366ff">节和</span><span style="color:#3366ff">2 4 . 2</span><span style="color:#3366ff">节，将介绍当产品支持路</span></p>
<p><span style="color:#3366ff">径</span><span style="color:#3366ff">M T U</span><span style="color:#3366ff">的发现方法时，</span><span style="color:#3366ff">U D P</span><span style="color:#3366ff">和</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">是如何进行操作的。</span></p>
<h3 id="TCP的超时与重传"><a href="#TCP的超时与重传" class="headerlink" title="ＴＣＰ的超时与重传"></a>ＴＣＰ的超时与重传</h3><p><span style="color:#3366ff">前面谈到TCP</span>如何保证传输可靠性是说到“当<span style="color:#3366ff">T C P</span><span style="color:#3366ff">发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段”，下面我看一下TCP</span>的超时与重传。</p>
<p><span style="color:#3366ff">T C P</span><span style="color:#3366ff">提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。</span></p>
<p><span style="color:#3366ff">对每个连接，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">管理</span><span style="color:#3366ff">4</span><span style="color:#3366ff">个不同的定时器。</span></p>
<p><span style="color:#3366ff">1) </span><span style="color:#3366ff">重传定时器使用于当希望收到另一端的确认。</span></p>
<p><span style="color:#3366ff">2) </span><span style="color:#3366ff">坚持</span><span style="color:#3366ff">( p e r s i s t )</span><span style="color:#3366ff">定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。</span></p>
<p><span style="color:#3366ff">3) </span><span style="color:#3366ff">保活</span><span style="color:#3366ff">( k e e p a l i v e )</span><span style="color:#3366ff">定时器可检测到一个空闲连接的另一端何时崩溃或重启。</span></p>
<p><span style="color:#3366ff">4) 2MSL</span><span style="color:#3366ff">定时器测量一个连接处于</span><span style="color:#3366ff">T I M E _ WA I T</span><span style="color:#3366ff">状态的时间。</span></p>
<p><span style="color:#3366ff">T C P</span><span style="color:#3366ff">超时与重传中最重要的部分就是对一个给定连接的往返时间（</span><span style="color:#3366ff"> RT T</span><span style="color:#3366ff">）的测量。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，</span><span style="color:#3366ff"> T C P</span><span style="color:#3366ff">应该跟踪这些变化并相应地改变其超时时间。</span></p>
<p><span style="color:#3366ff">大多数源于伯克利的</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">实现在任何时候对每个连接仅测量一次</span><span style="color:#3366ff">RT T</span><span style="color:#3366ff">&#20540;。在发送一个报文段时，如果给定连接的定时器已经被使用，则该报文段不被计时。</span></p>
<p><span style="color:#3366ff">具体</span><span style="color:#3366ff">RTT</span><span style="color:#3366ff">&#20540;的估算比较麻烦，需要可以参考《</span><span style="color:#3366ff">TCP-IP</span><span style="color:#3366ff">详解卷</span><span style="color:#3366ff">1</span><span style="color:#3366ff">第</span><span style="color:#3366ff">21</span><span style="color:#3366ff">章》</span></p>
<h3 id="TCP经受延时的确认"><a href="#TCP经受延时的确认" class="headerlink" title="TCP经受延时的确认"></a>TCP经受延时的确认</h3><p><span style="color:#3366ff">交互数据总是以小于最大报文段长度的分组发送。对于这些小的报文段，接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目</span><span style="color:#3366ff">。</span></p>
<p><span style="color:#3366ff">通常</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">在接收到数据时并不立即发送</span><span style="color:#3366ff">A C K</span><span style="color:#3366ff">；相反，它推迟发送，以便将</span><span style="color:#3366ff">A C K</span><span style="color:#3366ff">与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带</span><span style="color:#3366ff">A<br> C K</span><span style="color:#3366ff">）。绝大多数实现采用的时延为</span><span style="color:#3366ff">200 ms</span><span style="color:#3366ff">，也就是说，</span><span style="color:#3366ff">T C P</span><span style="color:#3366ff">将以最大</span><span style="color:#3366ff">200 ms</span><span style="color:#3366ff">的时延等待是否有数据一起发送。</span></p>
<p>我们看看另一位朋友的blog对此的介绍：</p>
<p><span style="color:green">摘要：当使用</span><span style="color:green">TCP</span><span style="color:green">传输小型数据包时，程序的设计是相当重要的。如果在设计方案中不对</span><span style="color:green">TCP</span><span style="color:green">数据包的</span><span style="color:green"></span></p>
<p><span style="color:green">延迟应答，</span><span style="color:green">Nagle</span><span style="color:green">算法，</span><span style="color:green">Winsock</span><span style="color:green">缓冲作用引起重视，将会严重影响程序的性能。这篇文章讨论了这些</span><span style="color:green"></span></p>
<p><span style="color:green">问题，列举了两个案例，给出了一些传输小数据包的优化设计方案。</span></p>
<p><span style="color:green">背景：当</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈接收到一个数据包时，会启动一个</span><span style="color:green">200</span><span style="color:green">毫秒的计时器。当</span><span style="color:green">ACK</span><span style="color:green">确认数据包</span><span style="color:green"></span></p>
<p><span style="color:green">发出之后，计时器会复位，接收到下一个数据包时，会再次启动</span><span style="color:green">200</span><span style="color:green">毫秒的计时器。为了提升应用程序</span><span style="color:green"></span></p>
<p><span style="color:green">在内部网和</span><span style="color:green">Internet</span><span style="color:green">上的传输性能，</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈使用了下面的策略来决定在接收到数据包后</span><span style="color:green"></span></p>
<p><span style="color:green">什么时候发送</span><span style="color:green">ACK</span><span style="color:green">确认数据包：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、如果在</span><span style="color:green">200</span><span style="color:green">毫秒的计时器超时之前，接收到下一个数据包，则立即发送</span><span style="color:green">ACK</span><span style="color:green">确认数据包。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、如果当前恰好有数据包需要发给</span><span style="color:green">ACK</span><span style="color:green">确认信息的接收端，则把</span><span style="color:green">ACK</span><span style="color:green">确认信息附带在数据包上立即发送。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、当计时器超时，</span><span style="color:green">ACK</span><span style="color:green">确认信息立即发送。</span><span style="color:green"></span></p>
<p><span style="color:green">为了避免小数据包拥塞网络，</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈默认启用了</span><span style="color:green">Nagle</span><span style="color:green">算法，这个算法能够将应用程序多次</span><span style="color:green"></span></p>
<p><span style="color:green">调用</span><span style="color:green">Send</span><span style="color:green">发送的数据拼接起来，当收到前一个数据包的</span><span style="color:green">ACK</span><span style="color:green">确认信息时，一起发送出去。下面是</span><span style="color:green">Nagle&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">算法的例外情况：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、如果</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈拼接起来的数据包超过了</span><span style="color:green">MTU</span><span style="color:green">&#20540;，这个数据会立即发送，而不等待前一个数据</span><span style="color:green"></span></p>
<p><span style="color:green">包的</span><span style="color:green">ACK</span><span style="color:green">确认信息。在以太网中，</span><span style="color:green">TCP</span><span style="color:green">的</span><span style="color:green">MTU(Maximum Transmission Unit)</span><span style="color:green">&#20540;是</span><span style="color:green">1460</span><span style="color:green">字节。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、如果设置了</span><span style="color:green">TCP_NODELAY</span><span style="color:green">选项，就会禁用</span><span style="color:green">Nagle</span><span style="color:green">算法，应用程序调用</span><span style="color:green">Send</span><span style="color:green">发送的数据包会立即被</span><span style="color:green"></span></p>
<p><span style="color:green">投递到网络，而没有延迟。</span><span style="color:green"></span></p>
<p><span style="color:green">为了在应用层优化性能，</span><span style="color:green">Winsock</span><span style="color:green">把应用程序调用</span><span style="color:green">Send</span><span style="color:green">发送的数据从应用程序的缓冲区复制到</span><span style="color:green">Winsock&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">内核缓冲区。</span><span style="color:green">Microsoft TCP</span><span style="color:green">栈利用类&#20284;</span><span style="color:green">Nagle</span><span style="color:green">算法的方法，决定什么时候才实际地把数据投递到网络。</span><span style="color:green"></span></p>
<p><span style="color:green">内核缓冲区的默认大小是</span><span style="color:green">8K</span><span style="color:green">，使用</span><span style="color:green">SO_SNDBUF</span><span style="color:green">选项，可以改变</span><span style="color:green">Winsock</span><span style="color:green">内核缓冲区的大小。如果有必要的话，</span><span style="color:green"></span></p>
<p>Winsock<span style="color:green">能缓冲大于</span><span style="color:green">SO_SNDBUF</span><span style="color:green">缓冲区大小的数据。在绝大多数情况下，应用程序完成</span><span style="color:green">Send</span><span style="color:green">调用仅仅表明数据</span><span style="color:green"></span></p>
<p><span style="color:green">被复制到了</span><span style="color:green">Winsock</span><span style="color:green">内核缓冲区，并不能说明数据就实际地被投递到了网络上。唯一一种例外的情况是：</span><span style="color:green"></span></p>
<p><span style="color:green">通过设置</span><span style="color:green">SO_SNDBUT</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">禁用了</span><span style="color:green">Winsock</span><span style="color:green">内核缓冲区。</span></p>
<p><span style="color:green">Winsock</span><span style="color:green">使用下面的规则来向应用程序表明一个</span><span style="color:green">Send</span><span style="color:green">调用的完成：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、如果</span><span style="color:green">socket</span><span style="color:green">仍然在</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额内，</span><span style="color:green">Winsock</span><span style="color:green">复制应用程序要发送的数据到内核缓冲区，完成</span><span style="color:green">Send</span><span style="color:green">调用。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、如果</span><span style="color:green">Socket</span><span style="color:green">超过了</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额并且先前只有一个被缓冲的发送数据在内核缓冲区，</span><span style="color:green">Winsock</span><span style="color:green">复制要发送</span><span style="color:green"></span></p>
<p><span style="color:green">的数据到内核缓冲区，完成</span><span style="color:green">Send</span><span style="color:green">调用。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、如果</span><span style="color:green">Socket</span><span style="color:green">超过了</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额并且内核缓冲区有不只一个被缓冲的发送数据，</span><span style="color:green">Winsock</span><span style="color:green">复制要发送的数据</span><span style="color:green"></span></p>
<p><span style="color:green">到内核缓冲区，然后投递数据到网络，直到</span><span style="color:green">Socket</span><span style="color:green">降到</span><span style="color:green">SO_SNDBUF</span><span style="color:green">限额内或者只剩余一个要发送的数据，才</span><span style="color:green"></span></p>
<p><span style="color:green">完成</span><span style="color:green">Send</span><span style="color:green">调用。</span></p>
<p><span style="color:green">案例</span><span style="color:green">1&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">一个</span><span style="color:green">Winsock TCP</span><span style="color:green">客户端需要发送</span><span style="color:green">10000</span><span style="color:green">个记录到</span><span style="color:green">Winsock TCP</span><span style="color:green">服务端，保存到数据库。记录大小从</span><span style="color:green">20</span><span style="color:green">字节到</span><span style="color:green">100&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">字节不等。对于简单的应用程序逻辑，可能的设计方案如下：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、客户端以阻塞方式发送，服务端以阻塞方式接收。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、客户端设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">，禁用</span><span style="color:green">Nagle</span><span style="color:green">算法，让每个数据包单独的发送。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、服务端在一个循环中调用</span><span style="color:green">Recv</span><span style="color:green">接收数据包。给</span><span style="color:green">Recv</span><span style="color:green">传递</span><span style="color:green">200</span><span style="color:green">字节的缓冲区以便让每个记录在一次</span><span style="color:green">Recv</span><span style="color:green">调用中</span><span style="color:green"></span></p>
<p><span style="color:green">被获取到。</span></p>
<p><span style="color:green">性能：</span><span style="color:green"></span></p>
<p><span style="color:green">在测试中发现，客户端每秒只能发送</span><span style="color:green">5</span><span style="color:green">条数据到服务段，总共</span><span style="color:green">10000</span><span style="color:green">条记录，</span><span style="color:green">976K</span><span style="color:green">字节左右，用了半个多小时</span><span style="color:green"></span></p>
<p><span style="color:green">才全部传到服务器。</span></p>
<p><span style="color:green">分析：</span><span style="color:green"></span></p>
<p><span style="color:green">因为客户端没有设置</span><span style="color:green">TCP_NODELAY</span><span style="color:green">选项，</span><span style="color:green">Nagle</span><span style="color:green">算法强制</span><span style="color:green">TCP</span><span style="color:green">栈在发送数据包之前等待前一个数据包的</span><span style="color:green">ACK</span><span style="color:green">确认</span><span style="color:green"></span></p>
<p><span style="color:green">信息。然而，客户端设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">，禁用了内核缓冲区。因此，</span><span style="color:green">10000</span><span style="color:green">个</span><span style="color:green">Send</span><span style="color:green">调用只能一个数据包一个数据</span><span style="color:green"></span></p>
<p><span style="color:green">包的发送和确认，由于下列原因，每个</span><span style="color:green">ACK</span><span style="color:green">确认信息被延迟</span><span style="color:green">200</span><span style="color:green">毫秒：</span><span style="color:green"></span></p>
<p>1<span style="color:green">、当服务器获取到一个数据包，启动一个</span><span style="color:green">200</span><span style="color:green">毫秒的计时器。</span><span style="color:green"></span></p>
<p>2<span style="color:green">、服务端不需要向客户端发送任何数据，所以，</span><span style="color:green">ACK</span><span style="color:green">确认信息不能被发回的数据包顺路携带。</span><span style="color:green"></span></p>
<p>3<span style="color:green">、客户端在没有收到前一个数据包的确认信息前，不能发送数据包。</span><span style="color:green"></span></p>
<p>4<span style="color:green">、服务端的计时器超时后，</span><span style="color:green">ACK</span><span style="color:green">确认信息被发送到客户端。</span></p>
<p><span style="color:green">如何提高性能：</span><span style="color:green"></span></p>
<p><span style="color:green">在这个设计中存在两个问题。第一，存在延时问题。客户端需要能够在</span><span style="color:green">200</span><span style="color:green">毫秒内发送两个数据包到服务端。</span><span style="color:green"></span></p>
<p><span style="color:green">因为客户端默认情况下使用</span><span style="color:green">Nagle</span><span style="color:green">算法，应该使用默认的内核缓冲区，不应该设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">为</span><span style="color:green">0</span><span style="color:green">。一旦</span><span style="color:green">TCP&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">栈拼接起来的数据包超过</span><span style="color:green">MTU</span><span style="color:green">&#20540;，这个数据包会立即被发送，不用等待前一个</span><span style="color:green">ACK</span><span style="color:green">确认信息。第二，这个设计</span><span style="color:green"></span></p>
<p><span style="color:green">方案对每一个如此小的的数据包都调用一次</span><span style="color:green">Send</span><span style="color:green">。发送这么小的数据包是不很有效率的。在这种情况下，应该</span><span style="color:green"></span></p>
<p><span style="color:green">把每个记录补充到</span><span style="color:green">100</span><span style="color:green">字节并且每次调用</span><span style="color:green">Send</span><span style="color:green">发送</span><span style="color:green">80</span><span style="color:green">个记录。为了让服务端知道一次总共发送了多少个记录，</span><span style="color:green"></span></p>
<p><span style="color:green">客户端可以在记录前面带一个头信息。</span></p>
<p><span style="color:green">案例二：</span><span style="color:green"></span></p>
<p><span style="color:green">一个</span><span style="color:green">Winsock TCP</span><span style="color:green">客户端程序打开两个连接和一个提供股票报价服务的</span><span style="color:green">Winsock TCP</span><span style="color:green">服务端通信。第一个连接</span><span style="color:green"></span></p>
<p><span style="color:green">作为命令通道用来传输股票编号到服务端。第二个连接作为数据通道用来接收股票报价。两个连接被建立后，</span><span style="color:green"></span></p>
<p><span style="color:green">客户端通过命令通道发送股票编号到服务端，然后在数据通道上等待返回的股票报价信息。客户端在接收到第一</span><span style="color:green"></span></p>
<p><span style="color:green">个股票报价信息后发送下一个股票编号请求到服务端。客户端和服务端都没有设置</span><span style="color:green">SO_SNDBUF</span><span style="color:green">和</span><span style="color:green">TCP_NODELAY&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">选项。</span></p>
<p><span style="color:green">性能：</span><span style="color:green"></span></p>
<p><span style="color:green">测试中发现，客户端每秒只能获取到</span><span style="color:green">5</span><span style="color:green">条报价信息。</span></p>
<p><span style="color:green">分析：</span></p>
<p><span style="color:green">这个设计方案一次只允许获取一条股票信息。第一个股票编号信息通过命令通道发送到服务端，立即接收到</span><span style="color:green"></span></p>
<p><span style="color:green">服务端通过数据通道返回的股票报价信息。然后，客户端立即发送第二条请求信息，</span><span style="color:green">send</span><span style="color:green">调用立即返回，</span><span style="color:green"></span></p>
<p><span style="color:green">发送的数据被复制到内核缓冲区。然而，</span><span style="color:green">TCP</span><span style="color:green">栈不能立即投递这个数据包到网络，因为没有收到前一个数据包的</span><span style="color:green"></span></p>
<p>ACK<span style="color:green">确认信息。</span><span style="color:green">200</span><span style="color:green">毫秒后，服务端的计时器超时，第一个请求数据包的</span><span style="color:green">ACK</span><span style="color:green">确认信息被发送回客户端，客户端</span><span style="color:green"></span></p>
<p><span style="color:green">的第二个请求包才被投递到网络。第二个请求的报价信息立即从数据通道返回到客户端，因为此时，客户端的</span><span style="color:green"></span></p>
<p><span style="color:green">计时器已经超时，第一个报价信息的</span><span style="color:green">ACK</span><span style="color:green">确认信息已经被发送到服务端。这个过程循环发生。</span></p>
<p><span style="color:green">如何提高性能：</span><span style="color:green"></span></p>
<p><span style="color:green">在这里，两个连接的设计是没有必要的。如果使用一个连接来请求和接收报价信息，股票请求的</span><span style="color:green">ACK</span><span style="color:green">确认信息会</span><span style="color:green"></span></p>
<p><span style="color:green">被返回的报价信息立即顺路携带回来。要进一步的提高性能，客户端应该一次调用</span><span style="color:green">Send</span><span style="color:green">发送多个股票请求，服务端</span><span style="color:green"></span></p>
<p><span style="color:green">一次返回多个报价信息。如果由于某些特殊原因必须要使用两个单向的连接，客户端和服务端都应该设置</span><span style="color:green">TCP_NODELAY&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="color:green">选项，让小数据包立即发送而不用等待前一个数据包的</span><span style="color:green">ACK</span><span style="color:green">确认信息。</span></p>
<p>提高性能的建议：</p>
<p>上面两个案例说明了一些最坏的情况。当设计一个方案解决大量的小数据包发送和接收时，应该遵循以下的建议：</p>
<p>1、如果数据片段不需要紧急传输的话，应用程序应该将他们拼接成更大的数据块，再调用Send。因为发送缓冲区</p>
<p>很可能被复制到内核缓冲区，所以缓冲区不应该太大，通常比8K小一点点是很有效率的。只要Winsock内核缓冲区</p>
<p>得到一个大于MTU&#20540;的数据块，就会发送若干个数据包，剩下最后一个数据包。发送方除了最后一个数据包，都不会</p>
<p>被200毫秒的计时器触发。</p>
<p>2、如果可能的话，避免单向的Socket数据流接连。</p>
<p>3、不要设置SO_SNDBUF为0，除非想确保数据包在调用Send完成之后立即被投递到网络。事实上，8K的缓冲区适合大多数</p>
<p>情况，不需要重新改变，除非新设置的缓冲区经过测试的确比默认大小更高效。</p>
<p>4、如果数据传输不用保证可靠性，使用UDP。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP提供了面向“连续字节流”的可靠的传输服务，TCP并不理解流所携带的数据内容，这个内容需要应用层自己解析。</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; “字节流”是连续的、非结构化的，而我们的应用需要的是有序的、结构化的数据信息，因此我们需要定义自己的“规则”去解读这个“连续的字节流“，那解决途径就是定义自己的封包类型，然后用这个类型去映射“连续字节流”。</p>
<p>如何定义封包，我们回顾一下前面这个数据进入协议栈的封装过程图：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733242750.jpg" target="_blank" rel="external"><img src="http://images.cnblogs.com/cnblogs_com/jiangtong/201203/201203221733251811.jpg" alt="clip_image007" title="clip_image007"></a></p>
<p>封包其实就是将上图中进入协议栈的用户数据[即用户要发送的数据]定义为一种方便识别和交流的类型，这有点类&#20284;信封的概念,信封就是一种人们之间通信的&#26684;式,信封&#26684;式如下：</p>
<p>信封&#26684;式：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收信人邮编</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收信人地址</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 收信人姓名</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 信件内容</p>
<p>那么在程序里面我们也需要定义这种&#26684;式：在C&#43;&#43;里面只有结构和类这种两种类型适合表达这个概念了。网络上很多朋友对此表述了自己的看法并贴出了代码：比如</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 数据封包信息定义开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>#pragma pack(push,1)&nbsp;&nbsp; //将原对齐方式压栈,采用新的1字节对齐方式</p>
<p>/<em> 封包类型枚举[此处根据需求列举] </em>/</p>
<p>typedef enum{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NLOGIN=1,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NREG=2,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NBACKUP=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NRESTORE=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NFILE_TRANSFER=4,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NHELLO=5</p>
<p>} PACKETTYPE;</p>
<p>/<em> 包头 </em>/</p>
<p>typedef struct tagNetPacketHead{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte version;//版本</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PACKETTYPE ePType;//包类型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD nLen;//包体长度</p>
<p>} NetPacketHead;</p>
<p>/<em> 封包对象[包头&amp;包体] </em>/</p>
<p>typedef struct tagNetPacket{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacketHead netPacketHead;//包头</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * packetBody;//包体</p>
<p>} NetPacket;</p>
<p>#pragma pack(pop)</p>
<p>/<strong><strong><strong>**</strong></strong></strong>数据封包信息定义结束<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发包顺序与收包问题</p>
<p>a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于TCP要通过协商解决发送出去的报文段的长度，因此我们发送的数据很有可能被分割甚至被分割后再重组交给网络层发送，而网络层又是采用分组传送，即网络层数据报到达目标的顺序完全无法预测，那么收包会出现半包、粘包问题。举个例子，发送端连续发送两端数据msg1和msg2，那么发送端[传输层]可能会出现以下情况：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1和msg2小于TCP的MSS，两个包按照先后顺序被发出，没有被分割和重组</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1过大被分割成两段TCP报文msg1-1、msg2-2进行传送,msg2较小直接被封装成一个报文传送</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1过大被分割成两段TCP报文msg1-1、msg2-2,msg1-1先被传送,剩下的msg1-2和msg2[较小]被组合成一个报文传送</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Msg1过大被分割成两段TCP报文msg1-1、msg2-2,msg1-1先被传送,剩下的msg1-2和msg2[较小]组合起来还是太小,组合的内容在和后面再发送的msg3的前部分数据组合起来发送</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ……………………….太多……………………..</p>
<p>b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接收端[传输层]可能出现的情况</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1,再收到msg2,这种方式太顺利了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1-1，再收到msg1-2，再收到msg2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iii.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1，再收到msg2-1,再收到msg2-2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iv.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先收到msg1和msg2-1,再收到msg2-2</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //…………还有很多………………</p>
<p>c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实“接收端网络层”接收到的分组数据报顺序和发送端比较可能完全是乱的，比如发“送端网络层”发送1、2、3、4、5，而接收端网络层接收到的数据报顺序却可能是2、1、5、4、3，但是“接收端的传输层”会保证链接的有序性和可靠性，“接收端的传输层”会对“接收端网络层”收到的顺序紊乱的数据报重组成有序的报文[即发送方传输层发出的顺序]，然后交给“接收端应用层”使用，所以“接收端传输层”总是能够保证数据包的有序性，“接收端应用层”[我们编写的socket程序]不用担心接收到的数据的顺序问题。</p>
<p>d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是如上所述，粘包问题和半包问题不可避免。我们在接收端应用层需要自己编码处理粘包和半包问题。一般做法是定义一个缓冲区或者是使用标准库/框架提供的容器循环存放接收到数据，边接收变判断缓冲区数据是否满足包头大小，如果满足包头大小再判断缓冲区剩下数据是否满足包体大小，如果满足则提取。详细步骤如下：</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接收数据存入缓冲区尾部</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区数据满足包头大小否</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区数据不满足包头大小，回到第1步；缓冲区数据满足包头大小则取出包头，接着判断缓冲区剩余数据满足包头中定义的包体大小否，不满足则回到第1步。</p>
<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区数据满足一个包头大小和一个包体大小之和，则取出包头和包体进行使用,此处使用可以采用拷贝方式转移缓冲区数据到另外一个地方，也可以为了节省内存直接采取调用回调函数的方式完成数据使用。</p>
<p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 清除缓冲区的第一个包头和包体信息，做法一般是将缓冲区剩下的数据拷贝到缓冲区首部覆盖“第一个包头和包体信息”部分即可。</p>
<p>粘包、半包处理具体实现很多朋友都有自己的做法，比如最前面贴出的链接，这里我也贴出一段参考：</p>
<p>缓冲区实现头文件：</p>
<p>#include &lt;windows.h&gt;</p>
<p>#ifndef _CNetDataBuffer<em>H</em></p>
<p>#define _CNetDataBuffer<em>H</em></p>
<p>#ifndef TCPLAB_DECLSPEC</p>
<p>#define TCPLAB_DECLSPEC _declspec(dllimport)</p>
<p>#endif</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 数据封包信息定义开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>#pragma pack(push,1)&nbsp;&nbsp; //将原对齐方式压栈,采用新的1字节对齐方式</p>
<p>/<em> 封包类型枚举[此处根据需求列举] </em>/</p>
<p>typedef enum{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NLOGIN=1,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NREG=2,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NBACKUP=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NRESTORE=3,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NFILE_TRANSFER=4,</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NHELLO=5</p>
<p>} PACKETTYPE;</p>
<p>/<em> 包头 </em>/</p>
<p>typedef struct tagNetPacketHead{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte version;//版本</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PACKETTYPE ePType;//包类型</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WORD nLen;//包体长度</p>
<p>} NetPacketHead;</p>
<p>/<em> 封包对象[包头&amp;包体] </em>/</p>
<p>typedef struct tagNetPacket{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacketHead netPacketHead;//包头</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * packetBody;//包体</p>
<p>} NetPacket;</p>
<p>#pragma pack(pop)</p>
<p>/<strong><strong><strong>**</strong></strong></strong>数据封包信息定义结束<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/</p>
<p>//缓冲区初始大小</p>
<p>#define BUFFER_INIT_SIZE 2048 </p>
<p>//缓冲区膨胀系数[缓冲区膨胀后的大小=原大小&#43;系数*新增数据长度]</p>
<p>#define BUFFER_EXPAND_SIZE 2</p>
<p>//计算缓冲区除第一个包头外剩下的数据的长度的宏[缓冲区数据总长度-包头大小]</p>
<p>#define BUFFER_BODY_LEN (m_nOffset-sizeof(NetPacketHead))</p>
<p>//计算缓冲区数据当前是否满足一个完整包数据量[包头&amp;包体]</p>
<p>#define HAS_FULL_PACKET ( \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (sizeof(NetPacketHead)&lt;=m_nOffset) &amp;&amp; \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((((NetPacketHead*)m_pMsgBuffer)-&gt;nLen) &lt;= BUFFER_BODY_LEN) \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )</p>
<p>//检查包是否合法[包体长度大于零且包体不等于空]</p>
<p>#define IS_VALID_PACKET(netPacket) \</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((netPacket.netPacketHead.nLen&gt;0) &amp;&amp; (netPacket.packetBody!=NULL))</p>
<p>//缓冲区第一个包的长度</p>
<p>#define FIRST_PACKET_LEN (sizeof(NetPacketHead)&#43;((NetPacketHead*)m_pMsgBuffer)-&gt;nLen)</p>
<p>/<em> 数据缓冲 </em>/</p>
<p>class /<em>TCPLAB_DECLSPEC</em>/ CNetDataBuffer</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> 缓冲区操作相关成员 </em>/</p>
<p>private:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *m_pMsgBuffer;//数据缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_nBufferSize;//缓冲区总大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_nOffset;//缓冲区数据大小</p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int GetBufferSize() const;//获得缓冲区的大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL ReBufferSize(int);//调整缓冲区的大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL IsFitPacketHeadSize() const;//缓冲数据是否适合包头大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL IsHasFullPacket() const;//缓冲区是否拥有完整的包数据[包含包头和包体]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL AddMsg(char *pBuf,int nLen);//添加消息到缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *GetBufferContents() const;//得到缓冲区内容</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Reset();//缓冲区复位[清空缓冲区数据,但并未释放缓冲区]</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Poll();//移除缓冲区首部的第一个数据包</p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNetDataBuffer();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~CNetDataBuffer();</p>
<p>};</p>
<p>#endif</p>
<p>缓冲区实现文件:</p>
<p>#define TCPLAB_DECLSPEC _declspec(dllexport)</p>
<p>#include &quot;CNetDataBuffer.h&quot;</p>
<p>/<em> 构造 </em>/</p>
<p>CNetDataBuffer::CNetDataBuffer()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nBufferSize = BUFFER_INIT_SIZE;//设置缓冲区大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset = 0;//设置数据偏移&#20540;[数据大小]为0</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = NULL;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = new char[BUFFER_INIT_SIZE];//分配缓冲区为初始大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(m_pMsgBuffer,BUFFER_INIT_SIZE);//缓冲区清空&nbsp;&nbsp;&nbsp; </p>
<p>}</p>
<p>/<em> 析构 </em>/</p>
<p>CNetDataBuffer::~CNetDataBuffer()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_nOffset!=0)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete [] m_pMsgBuffer;//释放缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = NULL;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nBufferSize=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset=0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 获得缓冲区中数据的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区中数据的大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>INT CNetDataBuffer::GetBufferSize() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this-&gt;m_nOffset;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 缓冲区中的数据大小是否足够一个包头大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/* Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果满足则返回True,否则返回False</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::IsFitPacketHeadSize() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sizeof(NetPacketHead)&lt;=m_nOffset;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 判断缓冲区是否拥有完整的数据包(包头和包体)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果缓冲区包含一个完整封包则返回True,否则False&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::IsHasFullPacket() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果连包头大小都不满足则返回</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if (!IsFitPacketHeadSize())</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return HAS_FULL_PACKET;//此处采用宏简化代码</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重置缓冲区大小&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> nLen:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 新增加的数据长度&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> Return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 调整结果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::ReBufferSize(int nLen)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *oBuffer = m_pMsgBuffer;//保存原缓冲区地址</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nLen=(nLen&lt;64?64:nLen);//保证最小增量大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //新缓冲区的大小=增加的大小&#43;原缓冲区大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nBufferSize = BUFFER_EXPAND_SIZE*nLen&#43;m_nBufferSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pMsgBuffer = new char[m_nBufferSize];//分配新的缓冲区,m_pMsgBuff指向新缓冲区地址</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(m_pMsgBuffer,m_nBufferSize);//新缓冲区清零</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory(m_pMsgBuffer,oBuffer,m_nOffset);//将原缓冲区的内容全部拷贝到新缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(…)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete []oBuffer;//释放原缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 向缓冲区添加消息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> pBuf:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要添加的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/* nLen:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 添加的消息长度</p>
<p>/<em> return:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 添加成功返回True,否则False&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetDataBuffer::AddMsg(char *pBuf,int nLen)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检查缓冲区长度是否满足,不满足则重新调整缓冲区大小</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_nOffset&#43;nLen&gt;m_nBufferSize)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReBufferSize(nLen);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //拷贝新数据到缓冲区末尾&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory(m_pMsgBuffer&#43;sizeof(char)*m_nOffset,pBuf,nLen);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset&#43;=nLen;//修改数据偏移</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch(…)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</p>
<p>}</p>
<p>/<em> 得到缓冲区内容 </em>/</p>
<p>const char * CNetDataBuffer::GetBufferContents() const</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_pMsgBuffer;</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 缓冲区复位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>void CNetDataBuffer::Reset()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_nOffset&gt;0)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_nOffset = 0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ZeroMemory(m_pMsgBuffer,m_nBufferSize);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> 移除缓冲区首部的第一个数据包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>void CNetDataBuffer::Poll()</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(m_nOffset==0 || m_pMsgBuffer==NULL)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (IsFitPacketHeadSize() &amp;&amp; HAS_FULL_PACKET)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyMemory(m_pMsgBuffer,m_pMsgBuffer&#43;FIRST_PACKET_LEN*sizeof(char),m_nOffset-FIRST_PACKET_LEN);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>对TCP发包和收包进行简单封装：</p>
<p>头文件：</p>
<p>#include &lt;windows.h&gt;</p>
<p>#include &quot;CNetDataBuffer.h&quot;</p>
<p>// #ifndef TCPLAB_DECLSPEC</p>
<p>// #define TCPLAB_DECLSPEC _declspec(dllimport)</p>
<p>// #endif</p>
<p>#ifndef _CNETCOMTEMPLATE<em>H</em></p>
<p>#define _CNETCOMTEMPLATE<em>H</em></p>
<p>//通信端口</p>
<p>#define TCP_PORT 6000</p>
<p>/<em> 通信终端[包含一个Socket和一个缓冲对象] </em>/</p>
<p>typedef struct {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET m_socket;//通信套接字</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNetDataBuffer m_netDataBuffer;//该套接字关联的数据缓冲区</p>
<p>} ComEndPoint;</p>
<p>/<em> 收包回调函数参数 </em>/</p>
<p>typedef struct{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacket *pPacket;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPVOID processor;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET comSocket;</p>
<p>} PacketHandlerParam;</p>
<p>class CNetComTemplate{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /<em> Socket操作相关成员 </em>/</p>
<p>private:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void SendPacket(SOCKET m_connectedSocket,NetPacket &amp;netPacket);//发包函数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BOOL RecvPacket(ComEndPoint &amp;comEndPoint,void (*recvPacketHandler)(LPVOID)=NULL,LPVOID=NULL);//收包函数</p>
<p>public:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CNetComTemplate();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~CNetComTemplate();</p>
<p>};</p>
<p>#endif</p>
<p>实现文件：</p>
<p>#include &quot;CNetComTemplate.h&quot;</p>
<p>CNetComTemplate::CNetComTemplate()</p>
<p>{</p>
<p>}</p>
<p>CNetComTemplate::~CNetComTemplate()</p>
<p>{</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:发包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> m_connectedSocket:建立好连接的套接字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> netPacket:要发送的数据包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>void CNetComTemplate::SendPacket(SOCKET m_connectedSocket,NetPacket &amp;netPacket)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_connectedSocket==NULL || !IS_VALID_PACKET(netPacket))//如果尚未建立连接则退出</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::send(m_connectedSocket,(char*)&amp;netPacket.netPacketHead,sizeof(NetPacketHead),0);//先发送包头</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ::send(m_connectedSocket,netPacket.packetBody,netPacket.netPacketHead.nLen,0);//在发送包体</p>
<p>}</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>/<em> Description:收包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> comEndPoint:通信终端[包含套接字和关联的缓冲区]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>/</p>
<p>/<em> recvPacketHandler:收包回调函数,当收到一个包后调用该函数进行包的分发处理</em>/</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>BOOL CNetComTemplate::RecvPacket(ComEndPoint &amp;comEndPoint,void (*recvPacketHandler)(LPVOID),LPVOID pCallParam)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (comEndPoint.m_socket==NULL)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int nRecvedLen = 0;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char pBuf[1024];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果缓冲区数据不够包大小则继续从套接字读取tcp报文段</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!(comEndPoint.m_netDataBuffer.IsHasFullPacket()))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nRecvedLen = recv(comEndPoint.m_socket,pBuf,1024,0);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nRecvedLen==SOCKET_ERROR || nRecvedLen==0)//若果Socket错误或者对方连接已经正常关闭则结束读取</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comEndPoint.m_netDataBuffer.AddMsg(pBuf,nRecvedLen);//将新接收的数据存入缓冲区</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //执行到此处可能是三种情况:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //1.已经读取到的数据满足一个完整的tcp报文段</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //2.读取发生socket_error错误</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //3.在还未正常读取完毕的过程中对方连接已经关闭</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果没有读取到数据或者没有读取到完整报文段则返回返回</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nRecvedLen==0 || (!(comEndPoint.m_netDataBuffer.IsHasFullPacket())))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (recvPacketHandler!=NULL)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造准备传递给回调函数的数据包</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NetPacket netPacket;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netPacket.netPacketHead = <em>(NetPacketHead</em>)comEndPoint.m_netDataBuffer.GetBufferContents();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netPacket.packetBody = new char[netPacket.netPacketHead.nLen];//动态分配包体空间</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //构造回调函数参数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PacketHandlerParam packetParam;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packetParam.pPacket = &amp;netPacket;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; packetParam.processor = pCallParam;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //呼叫回调函数</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recvPacketHandler(&amp;packetParam);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete []netPacket.packetBody;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //移除缓冲区的第一个包</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comEndPoint.m_netDataBuffer.Poll();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;</p>
<p>}</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2013/6/27 15:14:58 [原文链接](http://blog.csdn.net/kkaxiao/article/details/9188021)
&lt;/div&gt;
&lt;div&gt;
阅读：2216 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/9188021#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/06/27/转-关于Tcp封包/" data-id="cius3b9hp000bg4ifz8py1bp3" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-如何在IOS中使用block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/29/转-如何在IOS中使用block/" class="article-date">
  <time datetime="2012-12-29T12:04:03.000Z" itemprop="datePublished">2012-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/29/转-如何在IOS中使用block/">[转]如何在IOS中使用block</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如何在iOS中使用Block──How-to-use-Blocks-with-iOS"><a href="#如何在iOS中使用Block──How-to-use-Blocks-with-iOS" class="headerlink" title="如何在iOS中使用Block──How to use Blocks with iOS"></a><a href="http://www.cnblogs.com/pengyingh/articles/2343087.html" target="_blank" rel="external">如何在iOS中使用Block──How to use Blocks with iOS</a></h2><p>Block可以帮助我们组织独立的代码段，并提高复用性和可读性。iOS4在UIKit中引入了该特征。超过100个的Apple API都使用了Block，所以这是一个我们必须开始熟悉的知识。</p>
<p><strong>Block是什么样的？</strong>&nbsp;</p>
<p>你可以使用<em>^</em>操作符来声明一个Block变量，它表示一个Block的开始。</p>
<ol>
<li><span><span class="keyword">int</span><span>&nbsp;num1&nbsp;=&nbsp;7; &nbsp;</span></span></li>
<li><span class="keyword">int</span><span>(^aBlock)(</span><span class="keyword">int</span><span>)&nbsp;=&nbsp;^)</span><span class="keyword">int</span><span>&nbsp;num2)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;num1&#43;nunm2; &nbsp;</span></li>
<li><span>};&nbsp;&nbsp;</span></li>
</ol>
<p>在如上代码中我们将Block声明为一个变量，所以可以将它当做一个函数中使用：</p>
<ol>
<li><span><span>NSLog(@</span><span class="string">&quot;%d&quot;</span><span>,&nbsp;aBlock(49));&nbsp;//adds&nbsp;49&nbsp;</span><span class="keyword">to</span><span>&nbsp;7&nbsp;which&nbsp;gives&nbsp;us&nbsp;56.&nbsp;&nbsp;</span></span></li>
</ol>
<p>我们刚看过了将block当做变量的情况，但通常情况下我们会以内联的方式使用Block，比如在一个变量中。API要么会使用Block在一个对象集合上执行某种操作，要么将其作为一个操作完成后的回调。</p>
<ol>
<li><span><span>NSComperator&nbsp;compareStringsBlock&nbsp;=&nbsp;^(id&nbsp;stringA,&nbsp;id&nbsp;stringB)&nbsp;{ &nbsp;</span></span></li>
<li><span>NSRange&nbsp;rangeS&nbsp;&nbsp;=&nbsp;NSMakeRange&nbsp;(0,&nbsp;[stringA&nbsp;length]); &nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(stringA&nbsp;compare:stringB&nbsp;options:comparisonOptions&nbsp;range:rangeS&nbsp;locale:currentLocale]; &nbsp;</span></li>
<li><span>}; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>NSArray&nbsp;*compareSortArray&nbsp;&nbsp;=&nbsp;[arrayOfStringDays&nbsp;sortArrayUsingComparator:&nbsp;compareStringsBlock]);&nbsp;&nbsp;</span></li>
</ol>
<p>Block具有将临时函数体创建为表达式的优势。Apple文档中指出：&nbsp;</p>
<p>Block是符合如下要求的匿名内联的代码集：</p>
<ul>
<li>和函数一样具有一个指定类型的参数列表</li>
<li>&nbsp;有一个可以推导或声明的返回&#20540;类型</li>
<li>可以从它被定义的词义范围中捕捉状态</li>
<li>可以在需要的时候改变词义范围的状态</li>
<li>可以和相同的词义范围中定义的其他的Block共享更改的可能。</li>
<li>可以在词义范围（堆栈帧）被销毁后继续共享和修改该词义范围（堆栈帧）的状态。</li>
</ul>
<p>Block是一个自包含的小代码段，封装了用于遍历（线性遍历）或者回调，可以并发执行的任务单元。</p>
<p><strong>声明和使用Block</strong>&nbsp;</p>
<p>Apple文档中介绍了如何将一个Block声明为变量，并将其作为一个函数使用：</p>
<ol>
<li><span><span>int&nbsp;(^oneFrom)(int)&nbsp;=&nbsp;^(int&nbsp;anInt)&nbsp;{ &nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;anInt&nbsp;-&nbsp;1; &nbsp;</span></li>
<li><span>}; &nbsp;</span></li>
<li><span>//&nbsp;我们创建了一个内联块^(int&nbsp;anInt)…&nbsp;，其函数体和结果被传到了另外一个名为OneFrom的Block。 &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>printf(&quot;1&nbsp;from&nbsp;10&nbsp;is&nbsp;%d&quot;,&nbsp;oneFrom(10)); &nbsp;</span></li>
<li><span>//&nbsp;打印出：&nbsp;&quot;1&nbsp;from&nbsp;10&nbsp;is&nbsp;9&quot; &nbsp;</span></li>
<li><span>//&nbsp;这个block函数（distanceTraveled）传入3个float型参数，返回float&#20540;。&nbsp; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>float&nbsp;(^distanceTraveled)&nbsp;(float,&nbsp;float,&nbsp;float)&nbsp;= &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^(float&nbsp;startingSpeed,&nbsp;float&nbsp;acceleration,&nbsp;float&nbsp;time)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;</span><span class="attribute">distance</span><span>&nbsp;=&nbsp;(startingSpeed&nbsp;<em>&nbsp;time)&nbsp;&#43;&nbsp;(0.5&nbsp;</em>&nbsp;acceleration&nbsp;<em>&nbsp;time&nbsp;</em>&nbsp;time); &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;distance; &nbsp;</span></li>
<li><span>};&nbsp;</span></li>
</ol>
<p>&nbsp; 你也可以传入一个Block作为一个参数，而不要以如上的方式声明它们，这样就可以在需要将block作为参数的时候以内联代码的方式简单地实现。</p>
<ol>
<li><span><span>NSArray&nbsp;*anArray&nbsp;=&nbsp;[NSArray&nbsp;arrayWithObjects:&nbsp;@</span><span class="string">&quot;cat&quot;</span><span>,&nbsp;@</span><span class="string">&quot;dog&quot;</span><span>,nil]; &nbsp;</span></span></li>
<li><span>sortFunction(anArray,&nbsp;^(string&nbsp;<em>a&nbsp;string&nbsp;</em>b){ &nbsp;</span></li>
<li><span>if&nbsp;(&nbsp;a&nbsp;==&nbsp;@</span><span class="string">&quot;cat&quot;</span><span>)&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">TRUE</span><span>;&nbsp;});&nbsp;</span></li>
</ol>
<p>这样我们就看到一个内联的block代码段占据了最后一个参数（必须是参数列表的最后一个参数）的位置。Cocoa提供了很多使用Block的方法，这样你就可以传入Block作为方法的参数：</p>
<ol>
<li><span><span>NSArray&nbsp;*array&nbsp;=&nbsp;[NSArray&nbsp;arrayWithObjects:&nbsp;@</span><span class="string">&quot;A&quot;</span><span>,&nbsp;@</span><span class="string">&quot;B&quot;</span><span>,&nbsp;@</span><span class="string">&quot;C&quot;</span><span>,&nbsp;&nbsp;nil]; &nbsp;</span></span></li>
<li><span>NSSet&nbsp;*filterSet&nbsp;=&nbsp;[NSSet&nbsp;setWithObjects:&nbsp;@</span><span class="string">&quot;A&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Z&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Q&quot;</span><span>,&nbsp;nil]; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>BOOL&nbsp;(^test)(id&nbsp;obj,&nbsp;NSUInteger&nbsp;idx,&nbsp;BOOL&nbsp;*stop);&nbsp;//Block&nbsp;declaration&nbsp;</span><span class="keyword">returns</span><span>&nbsp;BOOL,&nbsp;params&nbsp;inc.&nbsp;id&nbsp;</span><span class="op">and</span><span>&nbsp;BOOL &nbsp;</span></li>
<li><span>//body&nbsp;</span><span class="keyword">of</span><span>&nbsp;block&nbsp;gets&nbsp;the&nbsp;block&nbsp;literal&nbsp;^(id&nbsp;obj,&nbsp;NSUInteger&nbsp;idx,&nbsp;Bool&nbsp;*stop)…&nbsp;</span><span class="op">and</span><span>&nbsp;the&nbsp;body&nbsp;logic&nbsp; &nbsp;</span></li>
<li><span>test&nbsp;=&nbsp;^&nbsp;(id&nbsp;obj,&nbsp;NSUInteger&nbsp;idx,&nbsp;BOOL&nbsp;*stop)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&amp;lt;&nbsp;5)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([filterSet&nbsp;containsObject:&nbsp;obj])&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;YES; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">NO</span><span>; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>};&nbsp;</span></li>
</ol>
<p>Apple提供的另外一个例子是：</p>
<ol>
<li><span><span>__block&nbsp;BOOL&nbsp;found&nbsp;=&nbsp;</span><span class="keyword">NO</span><span>; &nbsp;</span></span></li>
<li><span>NSSet&nbsp;*aSet&nbsp;=&nbsp;[NSSet&nbsp;setWithObjects:&nbsp;@</span><span class="string">&quot;Alpha&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Beta&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Gamma&quot;</span><span>,&nbsp;@</span><span class="string">&quot;X&quot;</span><span>,&nbsp;nil]; &nbsp;</span></li>
<li><span>NSString&nbsp;*string&nbsp;=&nbsp;@</span><span class="string">&quot;gamma&quot;</span><span>; &nbsp;</span></li>
<li><span>//we&nbsp;provide&nbsp;below&nbsp;a&nbsp;way&nbsp;</span><span class="keyword">of</span><span>&nbsp;how&nbsp;</span><span class="keyword">to</span><span>&nbsp;enumerate,&nbsp;using&nbsp;our&nbsp;own&nbsp;compare&nbsp;logic &nbsp;</span></li>
<li><span>[aSet&nbsp;enumerateObjectsUsingBlock:^(id&nbsp;obj,&nbsp;BOOL&nbsp;*stop)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([obj&nbsp;localizedCaseInsensitiveCompare:string]&nbsp;==&nbsp;NSOrderedSame)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*stop&nbsp;=&nbsp;YES; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;=&nbsp;YES; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>}];&nbsp;</span></li>
</ol>
<p>As you can see, it takes a little while to have it sink in but once you get it, it’s quite simple. I suggest looking at Apple’s documentation, as well as looking at the referenced APIs to see how they are used. Practice makes perfect.&nbsp;</p>
<p>&nbsp;</p>
<p>原文出处：<a href="http://answers.oreilly.com/topic/2281-how-to-use-blocks-with-ios/" title="http://answers.oreilly.com/topic/2281-how-to-use-blocks-with-ios/" target="_blank" rel="external">http://answers.oreilly.com/topic/2281-how-to-use-blocks-with-ios/</a></p>
<p>&nbsp;</p>
<p><a href="http://www.j2megame.org/index.php/content/view/2625/165.html" target="_blank" rel="external">objective-c block 详解</a></p>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><div>&nbsp;</div>

<p>Apple 在C, Objective-C, C&#43;&#43;加上Block這個延申用法。目前只有Mac 10.6 和iOS 4有支援。Block是由一堆可執行的程式組成，也可以稱做沒有名字的Function (Anonymous function)。如果是Mac 10.6 或 iOS 4.0 之前的平台可以利用 <a href="http://code.google.com/p/plblocks/" target="_blank" rel="external">http://code.google.com/p/plblocks/</a> 這個project得以支援Block語法。</p>
<p>Apple有一個叫做GCD(Grand Central Dispach)的新功能，用在同步處理(concurrency)的環境下有更好的效率。Block語法產生的動機就是來自於GCD，用Block包好 一個工作量交給GCD，GCD有一個宏觀的視野可以來分配CPU，GPU，Memory的來下最好的決定。</p>
<div><strong><span>Block 簡介</span></strong></div>

<p>Block其實行為和Function很像，最大的差別是在可以存取同一個Scope的變數&#20540;。</p>
<p>Block 實體會長成這樣</p>
<blockquote>
<p><strong>^(</strong>傳入<span>參數列</span><strong>) {</strong><span>行為主體</span><strong>}</strong>;</p>
</blockquote>
<p>Block實體開頭是&quot;^&quot;，接著是由小括號所包起來的<span>參數列</span>(比如 int a, int b, float c)，<span>行為的主體</span>由大括號包起來，專有名詞叫做block literal。<span>行為主體</span>可以用return回傳&#20540;，型別會被compiler自動辦識出來。如果沒有參數列要這樣寫(void)。</p>
<p>看個列子</p>
<blockquote>
<p>^(<span>int a</span>) {<span>return a*a;</span>};</p>
</blockquote>
<p>這是代表Block會回傳輸入&#20540;的平方&#20540;(<span>int a</span>&nbsp;就是<span>參數列</span>，<span>return a*a;</span>&nbsp;就是<span>行為主體</span>)。記得主體裡最後要加&quot;;&quot;因為是敘述，而整個{}最後也要要加&quot;;&quot;因為Block是個物件實體。</p>
<p>用法就是</p>
<blockquote>
<p>int result = ^(int a) {return a<em>a<strong>;</strong>} (5)<em>*;</em></em></p>
</blockquote>
<p>很怪吧。後面小括號裡的5 會被當成a的輸入&#20540;然後經由Block輸出5*5 = 25指定給result這個變數。</p>
<p>有沒有簡單一點的方法不然每次都要寫這麼長？有。接下來要介紹一個叫<strong>Block Pointer</strong>的東西來簡化我們的寫法。</p>
<p><strong>Block Pointer</strong>是這樣宣告的</p>
<blockquote>
<p>回傳&#20540;<span>&nbsp;</span><strong>(^</strong>名字<strong>) (</strong>參數列<strong>)</strong>;</p>
</blockquote>
<p>直接來看一個列子</p>
<blockquote>
<p>int (^<strong>square</strong>) (int);&nbsp;</p>
</blockquote>
<p>// 有一個叫<strong>square</strong>的<strong>Block Pointer</strong>，其所指向的Block是有一個int 輸入和 int 輸出</p>
<blockquote>
<p>square = ^(int a ) {return a*a ;}; // 將剛剛Block 實體指定給 square</p>
</blockquote>
<p>使用Block Pointer的例子</p>
<blockquote>
<p>int result = square(5); // 感覺上不就是funtion的用法嗎？</p>
</blockquote>
<p>也可以把Block Pointer當成參數傳給一個function，比如說</p>
<blockquote>
<p>void myFuction( int (^mySquare) (int) ); // function 的宣告，</p>
</blockquote>
<p>傳入一個有一個int輸入和int輸出的Block 型別的參數</p>
<p>呼叫這個myFunction的時候就是這樣呼叫</p>
<blockquote>
<p>int (^mySqaure) (int) = ^(int a) {return a*a;};<br>// 先給好一個有實體的block pointer叫mySquare</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>myFunction( mySqaure ) ; //把mySquare這個block pointer給myFunction這個function</p>
</blockquote>
<p>或是不用block pointer 直接給一個block 實體，就這樣寫</p>
<blockquote>
<p>&nbsp;myFunction(&nbsp;<strong>&nbsp;^(int a) {return a*a}</strong>&nbsp;) ;</p>
</blockquote>
<p>當成Objective-C method 的傳入&#20540;的話都是要把型別寫在變數前面然後加上小括號，因些應該就要這樣寫</p>
<blockquote>
<p>-(void) objcMethod:(&nbsp;<strong>int (^) (int)</strong>&nbsp;) square; // square 變數的型別是 int (^) (int)</p>
</blockquote>
<p>讀文至此是不是對Block有基本的認識？ 接下來我們要談談Block相關的行為和特色</p>
<p>首先是來看一下在Block裡面存取外部變數的方法</p>
<div><span><strong>存取變數</strong></span></div>

<p>1. 可以讀取和Block pointer同一個scope的變數&#20540;：</p>
<blockquote>
<p>{</p>
<p>int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) {return outA&#43;a;};</p>
<p>// block 裡面可以讀同一個scope的outA的&#20540;</p>
<p>int result = myPtr(3); // result is 11</p>
<p>}</p>
</blockquote>
<p>我們再來看一個很有趣的例子</p>
<blockquote>
<p>{</p>
<p>int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) {return outA&#43;a;};</p>
<p>// block 裡面可以讀同一個scope的outA的&#20540;</p>
<p><strong>outA = 5;</strong>&nbsp;// 在呼叫myPtr之前改變outA的&#20540;</p>
<p>int result = myPtr(3); // result 的&#20540;還是&nbsp;<strong>11</strong>並不是<strong>&nbsp;8</strong></p>
<p>}</p>
</blockquote>
<p>&nbsp;事實上呢，myPtr在其主體用到outA這個變數&#20540;的時候是做了一個copy的動作把outA的&#20540;copy下來。所以之後outA即使換了新的&#20540;對於myPtr裡copy的&#20540;是沒有影響到的。</p>
<p>要注意的是，這個指的&#20540;是變數的&#20540;，如果這個變數的&#20540;是一個記憶體的位置，換句話說，這個變數是個pointer的話，它指到的&#20540;是可以在block裡被改變的。</p>
<blockquote>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSMutableArray * mutableArray = [NSMutableArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;,nil];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = ^(int a) { [mutableArray removeLastObject];&nbsp; return a*a;} (5);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;test array %@&quot;, mutableArray);</p>
<p>}</p>
</blockquote>
<p>原本mutableArray的&#20540;是{@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;}在block裡被更改mutableArray所指向的物件後，mutableArray的&#20540;就會被成{@&quot;one&quot;,@&quot;two&quot;}</p>
<p>2. 直接存取static 的變數&nbsp;</p>
<blockquote>
<p>{</p>
<p>static int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) {return outA&#43;a;};</p>
<p>// block 裡面可以讀同一個scope的outA的&#20540;</p>
<p><strong>outA = 5;</strong>&nbsp;// 在呼叫myPtr之前改變outA的&#20540;</p>
<p>int result = myPtr(3); // result 的&#20540;是<strong>&nbsp;8</strong>，因為outA是個static 變數會直接反應其&#20540;</p>
<p>}</p>
</blockquote>
<p>甚至可以在block裡面直接改變outA的&#20540;比如這樣寫</p>
<blockquote>
<p>{</p>
<p>static int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) { outA= 5; return outA&#43;a;};</p>
<p>// block 裡面改變outA的&#20540;</p>
<p>int result = myPtr(3); // result 的&#20540;是<strong>&nbsp;8</strong>，因為outA是個static 變數會直接反應其&#20540;</p>
<p>}</p>
</blockquote>
<p>3. Block Variable</p>
<p>在某個變數前面如果加上修飾字<span><em></em></span><span></span>block 的話(注意block前有兩個下底線)，這個變數又稱為block variable。那麼在block裡就可以任意修改此變數&#20540;，變數&#20540;的改變也可以知道。</p>
<blockquote>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; __block int num = 5;</p>
<p>&nbsp;&nbsp;&nbsp; int (^myPtr) (int) = ^(int a) { return num&#43;&#43;;};</p>
<p>&nbsp;&nbsp;&nbsp; int (^myPtr2) (int) = ^(int a) { return num&#43;&#43;;};</p>
<p>&nbsp;&nbsp;&nbsp; int result = myPtr(0);</p>
<p>&nbsp;&nbsp;&nbsp; result = myPtr2(0);</p>
<p>}</p>
</blockquote>
<p>因為myPtr和myPtr2都有用到num這個block variable，最後result的&#20540;就會是7</p>
<div><strong><span>生命周期和記憶體管理</span></strong></div>

<p>因為block也是繼承自NSObject，所以其生命周期和記憶體的管理也就非常之重要。</p>
<p>block一開始都是被放到stack裡，換句話說其生命周期隨著method或function結束就會被回收，和一般變數的生命周期一樣。</p>
<p>關於記憶體的管理請遵循這幾個要點</p>
<p>1. block pointer的實體會在method或function結束後就會被清掉</p>
<p>2. 如果要保存block pointer的實體要用-<span>copy</span>指令，這樣block pointer就會被放到heap裡</p>
<p>&nbsp;&nbsp;&nbsp; 2.1 block 主體裡用到的block variable 也會被搬到heap 而有新的記憶體位置，且一並更新有用到這個block variable 的block都指到新的位置</p>
<p>&nbsp; &nbsp; 2.2 一般的variable&#20540;會被copy&nbsp;</p>
<p>&nbsp; &nbsp; 2.3 如果主體裡用到的variable是object的話，此object會被retain, block release時也會被release</p>
<p>&nbsp;&nbsp;&nbsp; 2.4 __block variable 裡用到的object是不會被retain的</p>
<p>首先來看一下這個例子</p>
<blockquote>
<p>typedef int (^MyBlock)(int);</p>
<p>MyBlock genBlock();</p>
<p>int main(){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock&nbsp;<strong>outBlock</strong>&nbsp;= genBlock();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = outBlock(5);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;result is %d&quot;,[outBlock retainCount] ); // segmentation fault</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;result is %d&quot;,result&nbsp; );</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;</p>
<p>}</p>
<p>MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock&nbsp;<strong>inBlock</strong>&nbsp;= ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;<strong>inBlock</strong>&nbsp;;</p>
<p>}</p>
</blockquote>
<p>此程式由genBlock裡產生的block再指定給main function的<strong>outBlock</strong>變數，執行這個程式會得到</p>
<p>Segmentation fault</p>
<p>(註：有時候把 genBlock裡的a 去掉就可以跑出結果的情形，這是系統cache住記憶體，並不是inBlock真得一直存在，久了還是會被回收，千萬不要以為是對的寫法)</p>
<p>表示我們用到了不該用的記憶體，在這個例子的情況下是在genBlock裡的<strong>inBlock</strong>變數在return的時候就被回收了，<strong>outBlock</strong>無法有一個合法的記憶體位置-retainCount就沒意義了。</p>
<p>如果這個時候需要保留inBlock的&#20540;就要用-copy指令，將genBlock改成</p>
<blockquote>
<p>&nbsp;MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [inBlock&nbsp;<span>copy</span>]&nbsp; ;</p>
<p>}</p>
</blockquote>
<p>這樣[inBlock copy]的回傳&#20540;就會被放到heap，就可以一直使用(記得要release)</p>
<p>執行結果是</p>
<p>result is 1</p>
<p>result is 15</p>
<p>再次提醒要記得release outBlock。</p>
<p>如果一回傳[inBlock copy]的&#20540;就不再需要的時候可以這樣寫</p>
<blockquote>
<p>&nbsp;MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [[inBlock&nbsp;<span>copy</span>]&nbsp;<span>autorelease</span>] ;</p>
<p>}</p>
</blockquote>
<p>-copy指令是為了要把block 從stack搬到heap，autorelease是為了平衝retainCount加到autorelease oop ，回傳之後等到事件結束就清掉。</p>
<p>接下來是block存取到的local variable是個物件的型別，然後做copy 指令時</p>
<blockquote>
<p>MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSMutableString * myString = [NSMutableString string];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;retain count of string %d&quot;,[myString retainCount]);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [inBlock copy] ;</p>
<p>}</p>
</blockquote>
<p>結果會印出</p>
<p>retain count of string 2</p>
<p>這個結果和上面2.3提到的一樣，local variable被retain了</p>
<p>那再來試試2.4，在local variable前面加上__block</p>
<blockquote>
<p>MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>__block</span>&nbsp;NSMutableString * myString = [NSMutableString string];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;retain count of string %d&quot;,[myString retainCount]);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [inBlock copy] ;</p>
<p>}</p>
</blockquote>
<p>執行的結果就是會</p>
<p>retain count of string 1</p>
<div><strong><span>Block Copying注意事項</span></strong></div>

<p>如果在Class method裡面做copying block動作的話</p>
<p>1. 在Block裡如果有直接存取到self，則self會被retain</p>
<p>2. 在Block裡如果取存到instance variable (無論直接或是從accessor)，則self會被retain</p>
<p>3. 取存到local variable所擁有的object時，這個object會被retain</p>
<p>讓我們來看一個自訂的Class</p>
<blockquote>
<p><span>@interface</span>&nbsp;MyObject : NSObject {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSString * title;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (^<span>myLog</span>) (NSString * deco);</p>
<p>}</p>
<p>-(void) logName;</p>
<p><span>@end</span></p>
<p><span>@implementation</span>&nbsp;MyObject</p>
<p>-(id) initWithTitle:(NSString * ) newTitle{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(self = [super init]){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title = newTitle;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>myLog</span>&nbsp;= [^(NSString * deco)&nbsp;<span>{</span>&nbsp;NSLog(@&quot;<span>%@%@%@</span>&quot;,deco, title, deco );<span>}</span>&nbsp;<span>copy</span>];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self;</p>
<p>}</p>
<p>-(void) logName{</p>
<p>&nbsp;myLog(@&quot;==&quot;);</p>
<p>}</p>
<p>-(void ) dealloc{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [myLog release];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [title release];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [super dealloc];</p>
<p>}</p>
<p><span>@end</span></p>
</blockquote>
<p>在main 裡使用如下</p>
<p>&nbsp;MyObject * mObj = [[MyObject alloc]&nbsp;<span>initWithTitle</span>:@&quot;Car&quot;];</p>
<p>&nbsp;NSLog(@&quot;retainCount of MyObject is&nbsp; %d&quot;,[mObj retainCount]&nbsp; );</p>
<p>&nbsp;[mObj logName];</p>
<p>其執行的結果為</p>
<p>retainCount of MyObject is&nbsp;<span>&nbsp;<span>2</span></span></p>
<p>==Car==</p>
<p>因為在MyObject的建構子裡myLog這個block pointer用了title這個instance variable然後就會retain self也就是MyObject的物件。</p>
<p>盡量不要這樣寫，會造成retain cycle，改善的方法是把建構子改成這樣</p>
<blockquote>
<p>-(id) initWithTitle:(NSString * ) newTitle{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(self = [super init]){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title = newTitle;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>myLog</span>&nbsp;= [^(NSString * deco)&nbsp;<span>{</span>&nbsp;NSLog(@&quot;<span>%@%@%@</span>&quot;,deco,&nbsp;<span>newTitle</span>, deco );<span>}</span>&nbsp;<span>copy</span>];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self;</p>
<p>}</p>
</blockquote>
<p>在Block主體裡用newTitle這個變數而不是title。這樣self就不會被retain了。</p>
<p>最後談一個小陷井</p>
<p>void (^myLog) (void);&nbsp;</p>
<p>BOOL result ;</p>
<p>if(result)</p>
<p>&nbsp;&nbsp;&nbsp; myLog = ^ {NSLog(@&quot;YES&quot;);};</p>
<p>else</p>
<p>&nbsp;&nbsp;&nbsp; myLog = ^ {NSLog(@&quot;NO&quot;);};</p>
<p>myLog();</p>
<p>這樣很可能就會當掉了，因為myLog 實體在if 或是else結束後就被清掉了。要記得。</p>
<p>要用copy來解決這個問題，但要記得release。</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/12/29 20:04:03 [原文链接](http://blog.csdn.net/kkaxiao/article/details/8451431)
&lt;/div&gt;
&lt;div&gt;
阅读：379 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/8451431#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/29/转-如何在IOS中使用block/" data-id="cius3b9h60006g4if8jvw1sha" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-APNS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/11/03/转-APNS/" class="article-date">
  <time datetime="2012-11-03T08:04:59.000Z" itemprop="datePublished">2012-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/11/03/转-APNS/">[转]APNS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Apple-Push-Notification-Service"><a href="#Apple-Push-Notification-Service" class="headerlink" title="Apple Push Notification Service"></a>Apple Push Notification Service</h1><p>Apple Push Notification service (APNs for short) is the centerpiece of the push notifications feature. It is a robust and highly efficient service for propagating information to devices such as iPhone, iPad, and iPod touch devices. Each device establishes<br> an accredited and encrypted IP connection with the service and receives notifications over this persistent connection. If a notification for an application arrives when that application is not running, the device alerts the user that the application has data<br> waiting for it. </p>
<p>Software developers (“providers”) originate the notifications in their server software. The provider connects with APNs through a persistent and secure channel while monitoring incoming data intended for their client applications. When new data for an application<br> arrives, the provider prepares and sends a notification through the channel to APNs, which pushes the notification to the target device.</p>
<p>In addition to being a simple but efficient and high-capacity transport service, APNs includes a default quality-of-service component that provides store-and-forward capabilities. See<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW4" target="_blank" rel="external">“Quality of Service”</a></span> for<br> more information. </p>
<p><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingWIthAPS/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW1" target="_blank" rel="external">“Provider Communication<br> with Apple Push Notification Service”</a></span> and <span class="content_text"><br><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/IPhoneOSClientImp/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW1" target="_blank" rel="external">“Scheduling, Registering, and Handling Notifications”</a></span><br> discuss the specific implementation requirements for providers and iOS applications, respectively.</p>
<p><a title="A Push Notification and Its Path" name="//apple_ref/doc/uid/TP40008194-CH100-SW10"></a></p>
<h2 id="A-Push-Notification-and-Its-Path"><a href="#A-Push-Notification-and-Its-Path" class="headerlink" title="A Push Notification and Its Path"></a>A Push Notification and Its Path</h2><p>Apple Push Notification service transports and routes a notification from a given provider to a given device. A notification is a short message consisting of two major pieces of data: the device token and the payload. The device token is analogous to a phone<br> number; it contains information that enables APNs to locate the device on which the client application is installed. APNs also uses it to authenticate the routing of a notification. The payload is a JSON-defined property list that specifies how the user of<br> an application on a device is to be alerted.</p>
<div class="notebox"><a title="Note" name="//apple_ref/doc/uid/TP40008194-CH100-SW16"></a><br><br><strong>Note:</strong> For more information about the device token, see <span class="content_text"><br><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW3" target="_blank" rel="external">“Security Architecture”</a></span>; for further information about<br> the notification payload, see <span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW1" target="_blank" rel="external">“The<br> Notification Payload”</a></span> .<br><br></div>

<p>The flow of remote-notification data is one-way. The provider composes a notification package that includes the device token for a client application and the payload. The provider sends the notification to APNs which in turn pushes the notification to the<br> device.</p>
<p>When it authenticates itself to APNs, a provider furnishes the service with its topic, which identifies the application for which it’s providing data. The topic is currently the bundle identifier of the target application on an iOS device.</p>
<p><a title="Figure 3-1A push notification from a provider to a client application" name="//apple_ref/doc/uid/TP40008194-CH100-SW6"></a><strong>Figure 3-1</strong>&nbsp; A push notification from a provider to a client application<img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/remote_notif_simple.jpg" alt="A remote notification from a provider to a client application"></p>
<p><span class="content_text">Figure 3-1</span> is a greatly simplified depiction of the virtual network APNs makes possible among providers and devices. The device-facing and provider-facing sides of APNs both have multiple points of connection; on the provider-facing<br> side, these are called gateways. There are typically multiple providers, each making one or more persistent and secure connections with APNs through these gateways. And these providers are sending notifications through APNs to many devices on which their client<br> applications are installed. <span class="content_text">Figure 3-2</span> is a slightly more realistic depiction.</p>
<p><a title="Figure 3-2Push notifications from multiple providers to multiple devices" name="//apple_ref/doc/uid/TP40008194-CH100-SW7"></a><strong>Figure 3-2</strong>&nbsp; Push notifications from multiple providers to multiple devices<img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/remote_notif_multiple.jpg" alt="Remote notifications from multiple providers to multiple devices"><a title="Feedback Service" name="//apple_ref/doc/uid/TP40008194-CH100-SW17"></a></p>
<h2 id="Feedback-Service"><a href="#Feedback-Service" class="headerlink" title="Feedback Service"></a>Feedback Service</h2><p>Sometimes APNs might attempt to deliver notifications for an application on a device, but the device may repeatedly refuse delivery because there is no target application. This often happens when the user has uninstalled the application. In these cases,<br> APNs informs the provider through a feedback service that the provider connects with. The feedback service maintains a list of devices per application for which there were recent, repeated failed attempts to deliver notifications. The provider should obtain<br> this list of devices and stop sending notifications to them. For more on this service, see<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CommunicatingWIthAPS/CommunicatingWIthAPS.html#//apple_ref/doc/uid/TP40008194-CH101-SW3" target="_blank" rel="external">“The Feedback Service.”</a></span></p>
<p><a title="Quality of Service" name="//apple_ref/doc/uid/TP40008194-CH100-SW4"></a></p>
<h2 id="Quality-of-Service"><a href="#Quality-of-Service" class="headerlink" title="Quality of Service"></a>Quality of Service</h2><p>Apple Push Notification Service includes a default Quality of Service (QoS) component that performs a store-and-forward function. If APNs attempts to deliver a notification but the device is offline, the QoS stores the notification. It retains only one notification<br> per application on a device: the last notification received from a provider for that application. When the offline device later reconnects, the QoS forwards the stored notification to the device. The QoS retains a notification for a limited period before deleting<br> it.</p>
<p><a title="Security Architecture" name="//apple_ref/doc/uid/TP40008194-CH100-SW3"></a></p>
<h2 id="Security-Architecture"><a href="#Security-Architecture" class="headerlink" title="Security Architecture"></a>Security Architecture</h2><p>To enable communication between a provider and a device, Apple Push Notification Service must expose certain entry points to them. But then to ensure security, it must also regulate access to these entry points. For this purpose, APNs requires two different<br> levels of trust for providers, devices, and their communications. These are known as connection trust and token trust.</p>
<p><strong>Connection trust</strong> establishes certainty that, on one side, the APNs connection is with an authorized provider with whom Apple has agreed to deliver notifications. At the device side of the connection, APNs must validate that the connection<br> is with a legitimate device.</p>
<p>After APNs has established trust at the entry points, it must then ensure that it conveys notifications to legitimate end points only. To do this, it must validate the routing of messages traveling through the transport; only the device that is the intended<br> target of a notification should receive it.</p>
<p>In APNs, assurance of accurate message routing—or <strong>token trust</strong>—is made possible through the device token. A device token is an opaque identifier of a device that APNs gives to the device when it first connects with it. The device shares the<br> device token with its provider. Thereafter, this token accompanies each notification from the provider. It is the basis for establishing trust that the routing of a particular notification is legitimate. (In a metaphorical sense, it has the same function as<br> a phone number, identifying the destination of a communication.)</p>
<div class="notebox"><a title="Note" name="//apple_ref/doc/uid/TP40008194-CH100-SW18"></a><br><br><strong>Note:</strong> A device token is not the same thing as the device UDID returned by the<br><code>[uniqueIdentifier](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIDevice_Class/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/occ/instm/UIDevice/uniqueIdentifier)</code> property of<br><code>UIDevice</code>.<br><br></div>

<p>The following sections discuss the requisite components for connection trust and token trust as well as the four procedures for establishing trust.</p>
<p><a title="Service-to-Device Connection Trust" name="//apple_ref/doc/uid/TP40008194-CH100-SW5"></a></p>
<h3 id="Service-to-Device-Connection-Trust"><a href="#Service-to-Device-Connection-Trust" class="headerlink" title="Service-to-Device Connection Trust"></a>Service-to-Device Connection Trust</h3><p>APNs establishes the identity of a connecting device through TLS peer-to-peer authentication. (Note that iOS takes care of this stage of connection trust; you do not need to implement anything yourself.) In the course of this procedure, a device initiates<br> a TLS connection with APNs, which returns its server certificate. The device validates this certificate and then sends its device certificate to APNs, which validates that certificate.</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_device_ct.jpg" alt="Service-to-device connection trust"><a title="Provider-to-Service Connection Trust" name="//apple_ref/doc/uid/TP40008194-CH100-SW11"></a></p>
<h3 id="Provider-to-Service-Connection-Trust"><a href="#Provider-to-Service-Connection-Trust" class="headerlink" title="Provider-to-Service Connection Trust"></a>Provider-to-Service Connection Trust</h3><p>Connection trust between a provider and APNs is also established through TLS peer-to-peer authentication. The procedure is similar to that described in<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW5" target="_blank" rel="external">“Service-to-Device Connection Trust.”</a></span><br> The provider initiates a TLS connection, gets the server certificate from APNs, and validates that certificate. Then the provider sends its provider certificate to APNs, which validates it on its end. Once this procedure is complete, a secure TLS connection<br> has been established; APNs is now satisfied that the connection has been made by a legitimate provider.</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/service_provider_ct.jpg" alt="Provider-to-service connection trust"></p>
<p>Note that provider connection is valid for delivery to only one specific application, identified by the topic (bundle ID) specified in the certificate. APNs also maintains a certificate revocation list; if a provider’s certificate is on this list, APNs may<br> revoke provider trust (that is, refuse the connection). </p>
<p><a title="Token Generation and Dispersal" name="//apple_ref/doc/uid/TP40008194-CH100-SW12"></a></p>
<h3 id="Token-Generation-and-Dispersal"><a href="#Token-Generation-and-Dispersal" class="headerlink" title="Token Generation and Dispersal"></a>Token Generation and Dispersal</h3><p>An iOS-based application must <strong>register</strong> to receive push notifications; it typically does this right after it is installed on a device. (This procedure is described in<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/IPhoneOSClientImp/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW1" target="_blank" rel="external">“Scheduling, Registering, and Handling<br> Notifications.”</a></span>) iOS receives the registration request from an application, connects with APNs, and forwards the request. APNs generates a device token using information contained in the unique device certificate. The device token contains an identifier<br> of the device. It then encrypts the device token with a token key and returns it to the device.</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/token_generation.jpg" alt="Token generation and dispersal"></p>
<p>The device returns the device token to the requesting application as an <code>NSData</code> object. The application then must then deliver the device token to its provider in either binary or hexadecimal format.&nbsp;<br><span class="content_text">Figure 3-3</span> also illustrates the token generation and dispersal sequence, but in addition shows the role of the client application in furnishing its provider with the device token.</p>
<p><a title="Figure 3-3Sharing the device token" name="//apple_ref/doc/uid/TP40008194-CH100-SW8"></a><strong>Figure 3-3</strong>&nbsp; Sharing the device token<img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/registration_sequence.jpg" alt="Sharing the device token"></p>
<p>The form of this phase of token trust ensures that only APNs generates the token which it will later honor, and it can assure itself that a token handed to it by a device is the same token that it previously provisioned for that particular device—and only<br> for that device.</p>
<p><a title="Token Trust (Notification)" name="//apple_ref/doc/uid/TP40008194-CH100-SW13"></a></p>
<h3 id="Token-Trust-Notification"><a href="#Token-Trust-Notification" class="headerlink" title="Token Trust (Notification)"></a>Token Trust (Notification)</h3><p>After iOS obtains a device token from APNs, as described in <span class="content_text"><br><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW12" target="_blank" rel="external">“Token Generation and Dispersal,”</a></span> it must provide<br> APNs with the token every time it connects with it. APNs decrypts the device token and validates that the token was generated for the connecting device. To validate, APNs ensures that the device identifier contained in the token matches the device identifier<br> in the device certificate. </p>
<p>Every notification that a provider sends to APNs for delivery to a device must be accompanied by the device token it obtained from an application on that device. APNs decrypts the token using the token key, thereby ensuring that the notification is valid.<br> It then uses the device ID contained in the device token to determine the destination device for the notification.</p>
<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Art/token_trust.jpg" alt="Token trust"><a title="Trust Components" name="//apple_ref/doc/uid/TP40008194-CH100-SW14"></a></p>
<h3 id="Trust-Components"><a href="#Trust-Components" class="headerlink" title="Trust Components"></a>Trust Components</h3><p>To support the security model for APNs, providers and devices must possess certain certificates, certificate authority (CA) certificates, or tokens.</p>
<ul>
<li><p><strong>Provider</strong>: Each provider requires a unique provider certificate and private cryptographic key for validating their connection with APNs. This certificate, provisioned by Apple, must identify the particular topic published by the provider;<br>the topic is the bundle ID of the client application. For each notification, the provider must furnish APNs with a device token identifying the target device. The provider may optionally wish to validate the service it is connecting to using the public server<br>certificate provided by the APNs server.</p>
</li>
<li><p><strong>Device</strong>: iOS uses the public server certificate passed to it by APNs to authenticate the service that it has connected to. It has a unique private key and certificate that it uses to authenticate itself to the service and establish the TLS<br>connection. It obtains the device certificate and key during device activation and stores them in the keychain. iOS also holds its particular device token, which it receives during the service connection process. Each registered client application is responsible<br>for delivering this token to its content provider.</p>
</li>
</ul>
<p>APNs servers also have the necessary certificates, CA certificates, and cryptographic keys (private and public) for validating connections and the identities of providers and devices.</p>
<p><a title="The Notification Payload" name="//apple_ref/doc/uid/TP40008194-CH100-SW1"></a></p>
<h2 id="The-Notification-Payload"><a href="#The-Notification-Payload" class="headerlink" title="The Notification Payload"></a>The Notification Payload</h2><p>Each push notification carries with it a payload. The payload specifies how users are to be alerted to the data waiting to be downloaded to the client application. The maximum size allowed for a notification payload is 256 bytes; Apple Push Notification<br> Service refuses any notification that exceeds this limit. Remember that delivery of notifications is “best effort” and is not guaranteed.</p>
<p>For each notification, providers must compose a JSON dictionary object that strictly adheres to RFC 4627. This dictionary must contain another dictionary identified by the key<br><code>aps</code>. The <code>aps</code> dictionary contains one or more properties that specify the following actions:</p>
<ul>
<li><p>An alert message to display to the user</p>
</li>
<li><p>A number to badge the application icon with</p>
</li>
<li><p>A sound to play<br><div class="notebox"><a title="Note" name="//apple_ref/doc/uid/TP40008194-CH100-SW19"></a></div></p>
</li>
</ul>
<p><strong>Note:</strong> Although you can combine an alert message, icon badging, and a sound in a single notification, you should consider the human-interface implications with push notifications. For example, a user might find frequent alert messages with<br> accompanying sound more annoying than useful, especially when the data to be downloaded is not critical.</p>
<p></p>
<p>If the target application isn’t running when the notification arrives, the alert message, sound, or badge value is played or shown. If the application is running, iOS delivers it to the application<br><span class="pediaLink"><a target="_self">delegate</a></span> as an <code>NSDictionary</code> object. The dictionary contains the corresponding Cocoa<br><span class="pediaLink"><a target="_self">property-list objects</a></span> (plus <code>NSNull</code>). </p>
<p>Providers can specify custom payload values outside the Apple-reserved <code>aps</code> namespace. Custom values must use the JSON structured and primitive types: dictionary (object), array, string, number, and Boolean. You should not include customer information<br> as custom payload data. Instead, use it for such purposes as setting context (for the user interface) or internal metrics. For example, a custom payload value might be a conversation identifier for use by an instant-message client application or a timestamp<br> identifying when the provider sent the notification. Any action associated with an alert message should not be destructive—for example, deleting data on the device.</p>
<div class="importantbox clear"><a title="Important" name="//apple_ref/doc/uid/TP40008194-CH100-DontLinkElementID_5"></a><br><br><strong>Important:</strong> Because delivery is not guaranteed, you should not depend on the remote-notifications facility for delivering critical data to an application via the payload. And never include sensitive data in the payload. You should use it<br> only to <em>notify</em> the user that new data is available.<br><br></div>

<p><span class="content_text">Table 3-1</span> lists the keys and expected values of the<br><code>aps</code> payload.</p>
<p><a title="Table 3-1Keys and values of the aps dictionary" name="//apple_ref/doc/uid/TP40008194-CH100-SW2"></a></p>
<div class="tableholder"><br><table class="graybox " border="0" cellspacing="0" cellpadding="5"><br><caption class="tablecaption"><strong>Table 3-1</strong>&nbsp; Keys and values of the<br><code>aps</code> dictionary</caption><br><tbody><br><tr><br><th class="TableHeading_TableRow_TableCell" scope="col"><br><br>Key<br><br></th><br><th class="TableHeading_TableRow_TableCell" scope="col"><br><br>Value type<br><br></th><br><th class="TableHeading_TableRow_TableCell" scope="col"><br><br>Comment<br><br></th><br></tr><br><tr><br><td scope="row"><br><br><code>alert</code><br><br></td><br><td><br><br>string or<br><br>dictionary<br><br></td><br><td><br><br>If this property is included, iOS displays a standard alert. You may specify a string as the value of<br><code>alert</code> or a dictionary as its value. If you specify a string, it becomes the message text of an alert with two buttons: Close and View. If the user taps View, the application is launched.&nbsp;<br><br>Alternatively, you can specify a dictionary as the value of <code>alert</code>. See<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW20" target="_blank" rel="external">Table 3-2</a></span> for descriptions<br> of the keys of this dictionary.<br><br></td><br></tr><br><tr><br><td scope="row"><br><br><code>badge</code><br><br></td><br><td><br><br>number<br><br></td><br><td><br><br>The number to display as the badge of the application icon. If this property is absent, the badge is not changed. To remove the badge, set the value of this property to<br><code>0</code>.<br><br></td><br></tr><br><tr><br><td scope="row"><br><br><code>sound</code><br><br></td><br><td><br><br>string<br><br></td><br><td><br><br>The name of a sound file in the application bundle. The sound in this file is played as an alert. If the sound file doesn’t exist or<br><code>default</code> is specified as the value, the default alert sound is played. The audio must be in one of the audio data formats that are compatible with system sounds; see<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/IPhoneOSClientImp/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW6" target="_blank" rel="external">“Preparing Custom Alert Sounds”</a></span><br> for details.<br><br></td><br></tr><br></tbody><br></table><br></div>

<p><a title="Table 3-2Child properties of the alert property" name="//apple_ref/doc/uid/TP40008194-CH100-SW20"></a></p>
<div class="tableholder"><br><table class="graybox " border="0" cellspacing="0" cellpadding="5"><br><caption class="tablecaption"><strong>Table 3-2</strong>&nbsp; Child properties of the<br><code>alert</code> property</caption><br><tbody><br><tr><br><th class="TableHeading_TableRow_TableCell" scope="col"><br><br>Key<br><br></th><br><th class="TableHeading_TableRow_TableCell" scope="col"><br><br>Value type<br><br></th><br><th class="TableHeading_TableRow_TableCell" scope="col"><br><br>Comment<br><br></th><br></tr><br><tr><br><td scope="row"><br><br><code>body</code><br><br></td><br><td><br><br>string<br><br></td><br><td><br><br>The text of the alert message.<br><br></td><br></tr><br><tr><br><td scope="row"><br><br><code>action-loc-key</code><br><br></td><br><td><br><br>string or <code>null</code><br><br></td><br><td><br><br>If a string is specified, displays an alert with two buttons, whose behavior is described in<br><span class="content_text">Table 3-1</span>. However, iOS uses the string as a key to get a localized string in the current localization to use for the right button’s title instead of “View”. If the value is<br><code>null</code>, the system displays an alert with a single OK button that simply dismisses the alert when tapped. See<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW21" target="_blank" rel="external">“Localized Formatted Strings”</a></span><br> for more information.<br><br></td><br></tr><br><tr><br><td scope="row"><br><br><code>loc-key</code><br><br></td><br><td><br><br>string<br><br></td><br><td><br><br>A key to an alert-message string in a <code>Localizable.strings</code> file for the current localization (which is set by the user’s language preference). The key string can be formatted with<br><code>%@</code> and <code>%</code><em>n</em><code>$@</code> specifiers to take the variables specified in<br><code>loc-args</code>. See <span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW21" target="_blank" rel="external">“Localized<br> Formatted Strings”</a></span> for more information.<br><br></td><br></tr><br><tr><br><td scope="row"><br><br><code>loc-args</code><br><br></td><br><td><br><br>array of strings<br><br></td><br><td><br><br>Variable string values to appear in place of the format specifiers in <code>loc-key</code>. See<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/ApplePushService/ApplePushService.html#//apple_ref/doc/uid/TP40008194-CH100-SW21" target="_blank" rel="external">“Localized Formatted Strings”</a></span><br> for more information.<br><br></td><br></tr><br><tr><br><td scope="row"><br><br><code>launch-image</code><br><br></td><br><td><br><br>string<br><br></td><br><td><br><br>The filename of an image file in the application bundle; it may include the extension or omit it. The image is used as the launch image when users tap the action button or move the action slider. If this property is not specified, the system either uses<br> the previous snapshot,uses the image identified by the <code>UILaunchImageFile</code> key in the application’s<br><code>Info.plist</code> file, or falls back to <code>Default.png</code>.<br><br>This property was added in iOS 4.0.<br><br></td><br></tr><br></tbody><br></table><br></div><br><div class="notebox"><a title="Note" name="//apple_ref/doc/uid/TP40008194-CH100-SW22"></a><br><br><strong>Note:</strong> If you want the iPhone, iPad, or iPod touch device to display the message text as-is in an alert that has both the Close and View buttons, then specify a string as the direct value of alert.<br><em>Don’t</em> specify a dictionary as the value of <code>alert</code> if the dictionary only has the<br><code>body</code> property.<br><br></div><br><a title="Localized Formatted Strings" name="//apple_ref/doc/uid/TP40008194-CH100-SW21"></a><br><br>### Localized Formatted Strings<br><br>You can display localized alert messages in two ways. The server originating the notification can localize the text; to do this, it must discover the current language preference selected for the device (see<br><span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/IPhoneOSClientImp/IPhoneOSClientImp.html#//apple_ref/doc/uid/TP40008194-CH103-SW3" target="_blank" rel="external">“Passing the Provider the Current<br> Language Preference (Remote Notifications)”</a></span>). Or the client application can store in its bundle the alert-message strings translated for each localization it supports. The provider specifies the<br><code>loc-key</code> and <code>loc-args</code> properties in the <code>aps</code> dictionary of the notification payload. When the device receives the notification (assuming the application isn’t running), it uses these<br><code>aps</code>-dictionary properties to find and format the string localized for the current language, which it then displays to the user.<br><br>Here’s how that second option works in a little more detail.<br><br>An iOS application can <span class="pediaLink"><a target="_self">internationalize</a></span> resources such as images, sounds, and text for each language that it supports, Internationalization collects the resources and puts them in a subdirectory of the<br> bundle with a two-part name: a language code and an extension of <code>.lproj</code> (for example,<br><code>fr.lproj</code>). Localized strings that are programmatically displayed are put in a file called<br><code>Localizable.strings</code>. Each entry in this file has a key and a localized string value; the string can have format specifiers for the substitution of variable values. When an application asks for a particular resource—say a localized string—it gets<br> the resource that is localized for the language currently selected by the user.&nbsp; For example, if the preferred language is French, the corresponding string value for an alert message would be fetched from<br><code>Localizable.strings</code> in the <code>fr.lproj</code> directory in the application bundle. (iOS makes this request through the<br><code>[NSLocalizedString](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/Reference/reference.html#//apple_ref/c/macro/NSLocalizedString)</code> macro.)<br><br><div class="notebox"><a title="Note" name="//apple_ref/doc/uid/TP40008194-CH100-SW24"></a><br><br><strong>Note:</strong> This general pattern is also followed when the value of the<br><code>action-loc-key</code> property is a string. This string is a key into the <code>Localizable.strings</code> in the localization directory for the currently selected language. iOS uses this key to get the title of the button on the right side of an alert message (the “action” button).<br><br></div>

<p>To make this clearer, let’s consider an example. The provider specifies the following dictionary as the value of the alert property:</p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>&quot;alert&quot; : { &quot;loc-key&quot; : &quot;GAME_PLAY_REQUEST_FORMAT&quot;, &quot;loc-args&quot; : [ &quot;Jenna&quot;, &quot;Frank&quot;] },<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p>When the device receives the notification, it uses <code>&amp;quot;GAME_PLAY_REQUEST_FORMAT&amp;quot;</code> as a key to look up the associated string value in the<br><code>Localizable.strings</code> file in the <code>.lproj</code> directory for the current language. Assuming the current localization has an<br><code>Localizable.strings</code> entry such as this: </p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>&quot;GAME_PLAY_REQUEST_FORMAT&quot; = &quot;%@ and %@ have invited you to play Monopoly&quot;;<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p>the device displays an alert with the message “Jenna and Frank have invited you to play Monopoly”.</p>
<p>In addition to the format specifier <code>%@</code>, you can <code>%</code><em>n</em><code>$@</code> format specifiers for positional substitution of string variables. The<br><em>n</em> is the index (starting with 1) of the array value in <code>loc-args</code> to substitute. (There’s also the<br><code>%%</code> specifier for expressing a percentage sign (%).) So if the entry in<br><code>Localizable.strings</code> is this:</p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>&quot;GAME_PLAY_REQUEST_FORMAT&quot; = &quot;%2$@ and %1$@ have invited you to play Monopoly&quot;;<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p>the device displays an alert with the message &quot;Frank and Jenna have invited you to play Monopoly&quot;.</p>
<p>For a full example of a notification payload that uses the <code>loc-key</code> and<br><code>loc-arg</code> properties, see the last example of <span class="content_text"><br>“Examples of JSON Payloads.”</span> To learn more about internationalization in iOS, see “<span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/AdvancedAppTricks/AdvancedAppTricks.html#//apple_ref/doc/uid/TP40007072-CH7" target="_blank" rel="external">“Advanced<br> App Tricks”</a></span>” in _<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="external">iOS App Programming Guide</a><em>; for general<br> information about internationalization, see </em><a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/BPInternational.html#//apple_ref/doc/uid/10000171i" target="_blank" rel="external">Internationalization Programming Topics</a>_.<br> String formatting is discussed in <span class="content_text"><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/Articles/FormatStrings.html#//apple_ref/doc/uid/20000943" target="_blank" rel="external">“Formatting String Objects”</a></span><br> in _<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Strings/introStrings.html#//apple_ref/doc/uid/10000035i" target="_blank" rel="external">String Programming Guide</a>_.</p>
<div class="notebox"><a title="Note" name="//apple_ref/doc/uid/TP40008194-CH100-SW23"></a><br><br><strong>Note:</strong> You should use the <code>loc-key</code> and <code>loc-args</code> properties—and the<br><code>alert</code> dictionary in general—only if you absolutely need to. The values of these properties, especially if they are long strings, might use up more bandwidth than is good for performance. Many if not most applications may not need these properties<br> because their message strings are originated by users and thus are implicitly &quot;localized.&quot;<br><br></div><br><a title="Examples of JSON Payloads" name="//apple_ref/doc/uid/TP40008194-CH100-SW15"></a><br><br>### Examples of JSON Payloads<br><br>The following examples of the payload portion of notifications illustrate the practical use of the properties listed in<br><span class="content_text">Table 3-1</span>. Properties with “acme” in the key name are examples of custom payload data. The examples include whitespace and newline characters for readability; for better performance, providers should omit whitespace and newline<br> characters.<br><br><strong>Example 1</strong>: The following payload has an <code>aps</code> dictionary with a simple, recommended form for alert messages with the default alert buttons (Close and View). It uses a string as the value of<br><code>alert</code> rather than a dictionary. This payload also has a custom array property.<br><br><div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>{<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;aps&quot; : { &quot;alert&quot; : &quot;Message received from Bob&quot; },<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;acme2&quot; : [ &quot;bang&quot;,  &quot;whiz&quot; ]<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>}<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p><strong>Example 2</strong>. The payload in the example uses an <code>aps</code> dictionary to request that the device display an alert message with an Close button on the left and a localized title for the &quot;action&quot; button on the right side of the alert.<br> In this case, “PLAY” is used as a key into the <code>Localizable.strings</code> file for the currently selected language to get the localized equivalent of “Play”. The<br><code>aps</code> dictionary also requests that the application icon be badged with 5.</p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>{     &quot;aps&quot; : {         &quot;alert&quot; : { &quot;body&quot; : &quot;Bob wants to play poker&quot;, &quot;action-loc-key&quot; : &quot;PLAY&quot; },         &quot;badge&quot; : 5,     },     &quot;acme1&quot; : &quot;bar&quot;,     &quot;acme2&quot; : [ &quot;bang&quot;,  &quot;whiz&quot; ] }<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p><strong>Example 3</strong>. The payload in this example specifies that device should display an alert message with both Close and View buttons. It also request that the application icon be badged with 9 and that a bundled alert sound be played when the notification<br> is delivered.</p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>{<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;aps&quot; : {<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>        &quot;alert&quot; : &quot;You got your emails.&quot;,<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>        &quot;badge&quot; : 9,<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>        &quot;sound&quot; : &quot;bingbong.aiff&quot;<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    },<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;acme1&quot; : &quot;bar&quot;,<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;acme2&quot; : 42<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>}<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p><strong>Example 4</strong>. The interesting thing about the payload in this example is that it uses the<br><code>loc-key</code> and <code>loc-args</code> child properties of the <code>alert</code> dictionary to fetch a formatted localized string from the application’s bundle and substitute the variable string values (<code>loc-args</code>) in the appropriate places.<br> It also specifies a custom sound and include a custom property. </p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>{<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;aps&quot; : {<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>        &quot;alert&quot; : { &quot;loc-key&quot; : &quot;GAME_PLAY_REQUEST_FORMAT&quot;, &quot;loc-args&quot; : [ &quot;Jenna&quot;, &quot;Frank&quot;] },<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>        &quot;sound&quot; : &quot;chime&quot;<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    },<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;acme&quot; : &quot;foo&quot;<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>}<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p><strong>Example 5</strong>. The following example shows an empty <code>aps</code> dictionary; because the<br><code>badge</code> property is missing, any current badge number shown on the application icon is removed. The<br><code>acme2</code> custom property is an array of two integers.</p>
<div class="codesample clear"><br><table><br><tbody><br><tr><br><td scope="row"><br><pre>{<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;aps&quot; : {<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    },<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>    &quot;acme2&quot; : [ 5,  8 ]<span></span></pre><br></td><br></tr><br><tr><br><td scope="row"><br><pre>}<span></span></pre><br></td><br></tr><br></tbody><br></table><br></div>

<p>Remember, for better performance, you should strip all whitespace and newline characters from the payload before including it in the notification</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/11/3 16:04:59 [原文链接](http://blog.csdn.net/kkaxiao/article/details/8143791)
&lt;/div&gt;
&lt;div&gt;
阅读：1237 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/8143791#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/11/03/转-APNS/" data-id="cius3b9gy0003g4if0o1nmhot" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-软件许可协议解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/09/11/转-软件许可协议解析/" class="article-date">
  <time datetime="2012-09-11T08:58:25.000Z" itemprop="datePublished">2012-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/11/转-软件许可协议解析/">[转]软件许可协议解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下内容转载自<a href="http://blog.csdn.net/tianma2008/article/details/7199965" target="_blank" rel="external">http://blog.csdn.net/tianma2008/article/details/7199965</a></p>
<p>&nbsp;</p>
<p>去年搭建企业应用开发平台时，因为涉及到架构选型，好好研究了一下软件许可协议，特别是开源协议，并做了整理。近期温习了一下，觉得很有用，对于想要自己搭建开发平台的弟兄们，可能会有点帮助。</p>
<p>软件许可协议包括商业许可协议和开源协议。</p>
<p>商业许可协议一般比较严厉，当然也会分一些层级，不同的公司会有不同的规定，比如润乾报表按部署的报表服务数量收费，Oracle按cpu个数或scema数收费等等，以相应公司公司的许可协议为准。不过有个共性，就是基本都不开放源码。</p>
<p>开源协议，顾名思义，就是要开放源码。目前公认的开源协议有不少，其松紧程度也不一样，下面是常用的一些开源协议：</p>
<p><strong>1、BSD协议（Berkeley Software Distribution）</strong></p>
<p>采用这种协议的软件有：开源UNIX，</p>
<p>BSD开源协议是一个给予使用者很大自由的协议。基本上使用者可以“为所欲为”可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但“为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<p>(1)如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</p>
<p>(2)如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</p>
<p>(3)不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</p>
<p>其实这几个规则约定的目的也只是达到一个目的：是他人的东西，别人以BSD开源了，你就不能不做任何声明而占为己有，更不能用他人的名义来做商业推广。你只对你自己的东西拥有绝对控制权。</p>
<p>举个例子，你用开源代码(A)修改或做其他增添之后，产生了产品B，这时候，你对B的控制由你自己决定，你可以用任何协议再开源，也可以闭源商业发布。但因为如果B中包含了A或A的一部分(一点都不包含就不叫修改了)，那你在B产品的版权声明中，必须有提到你有使用到A，并且附带上A的开源协议。而且不能做商业推广的时候将B冠以原开源作者的名义以促进商业推广。</p>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<p><strong>2、Apache Licence 2.0</strong></p>
<p>采用这种协议的软件有：Apache组织下的开源软件</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类&#20284;，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布(作为开源或商业软件)。需要满足的条件也和BSD类&#20284;：</p>
<p>(1)需要给代码的用户一份Apache Licence</p>
<p>(2)如果你修改了代码，需要再被修改的文件中说明。</p>
<p>(3)在延伸的代码中(修改和有源代码衍生的代码中)需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</p>
<p>(4)如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</p>
<p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售</p>
<p><strong>3、GPL2.0（General Public License）</strong></p>
<p>采用这种协议的软件有：linux,ext2,jquery easyUI,dhtmlxgrid,mysql等</p>
<p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache </p>
<p>Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p>
<p>GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用，修改后的代码或者衍生代码)GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的“传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p>
<p>由于GPL严&#26684;要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p>
<p>最常见的开源协议，使用它作为授权协议的有大名鼎鼎的Linux。GPL最显著的两个特点就是网上称为的“病毒性传播”和“不允许闭源的商业发布”。</p>
<p>所谓的“病毒性传播”，指的是，GPL规定，所有从GPL协议授权的源码衍生出来的(即上面提到的Derivative Module)，或者要跟GPL授权的源码混着用的Project，都要遵循GPL协议，就像病毒一样，粘上了关系，就“中毒”了。GPL这样规定的目的是，保证在GPL协议保护下的产品，不会再受到其他协议或者授权的约束。即让跟GPL有关系的源码都能免费获取。举个例子，如果你的改进的Linux中使用了GPL授权下的开源模块(也必须使用，你不可能自己重新去做个内核吧，如果做出来了，你也没必要叫Linux了。)，那么你整个Linux产品也必须遵循GPL协议去开源，不能以其他方式去开源发布，更不允许闭源发布。这样一来，就不会出现这样一个Linux–这个功能是GPL协议授权的，可以免费获取源码，而另外一个功能是其他协议下的，拿不到源码。这点规定对使用或者研究该产品的人来说，是一个极大的便利。</p>
<p>而“不允许闭源商业发布”指的是，在GPL授权下，你的软件产品可以商业发布，拿去卖钱，但是在这同时，你也必须将该产品的源码以GPL协议方式开源发布出去，供他人免费获取。也许有人会迷惑，拿去卖，又同时开源，那谁来买阿?这个产品怎么赚钱呢??这就涉及到开源产品的商业模式的问题了，想了解相关一些信息的话，可以看看以上我给出链接的一些文章。至于后面，可能会写一篇关于开源项目的商业模式的随笔。</p>
<p>GPL协议下的商业发布的一个关键点就像Java视线论坛的Robbin所说的，GPL是针对软件源代码的版权，而不是针对软件编译后二进制版本的版权。你有权免费获得软件的源代码，但是你没有权力免费获得软件的二进制发行版本。GPL对软件发行版本唯一的限制就是：你的发行版本必须把完整的源代码一同提供。</p>
<p>它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类&#20284;。</p>
<p><strong>4、LGPL</strong></p>
<p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类&#20284;的产品。</p>
<p><strong>5、CPL1.0(Common Public Liecense)</strong></p>
<p>采用这种协议的软件有：Eclipse组织下的一些软件，包括ECLIPSE IDE,ECLIPSE BIRT等。</p>
<p>CPL是IBM提出的并通过了OSI(Open Source Initiative)批准的开源协议。主要用于一些IBM或跟IBM相关的开源软件/项目中。如很著名的Java开发环境Eclipse、RIA开发平台Open Laszlo等。</p>
<p>CPL也是一项对商业应用友好的协议。它允许Recipients对源码进行任意的使用、复制、分发、传播、展示、修改以及改后做闭源的二次商业发布，这点跟BSD很类&#20284;，也属于自由度比较高的开源协议。但是，需要遵循：</p>
<p>(1)当一个Contributors将源码的整体或部分再次开源发布的时候，必须继续遵循CPL开源协议来发布，而不能改用其他协议发布。除非你得到了原“源码”Owner的授权。</p>
<p>(2)CPL协议下，你可以将源码不做任何修改来商业发布。但如果你要将修改后的源码开源，而且当你再发布的是Object Code的时候，你必须声明它的Source Code是可以获取的，而且要告知获取方法。</p>
<p>(3)当你需要将CPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候，你可以将整个Project/Product以私人的协议发布，但要声明哪一部分代码是CPL下的，而且声明那部分代码继续遵循CPL。</p>
<p>(4)独立的模块(Separate Module)，不需要开源。</p>
<p><strong>6、MIT</strong></p>
<p>采用这种协议的软件有：jQuery</p>
<p>MIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他的限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/9/11 16:58:25 [原文链接](http://blog.csdn.net/kkaxiao/article/details/7967959)
&lt;/div&gt;
&lt;div&gt;
阅读：583 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/7967959#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/09/11/转-软件许可协议解析/" data-id="cius3b9h90007g4ifrt8h0mn3" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-杂记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/08/19/原-杂记/" class="article-date">
  <time datetime="2012-08-19T09:17:53.000Z" itemprop="datePublished">2012-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/08/19/原-杂记/">[原]杂记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一. 风险与问题</p>
<div><span style="color:#ff0000">1、风险不同于问题，问题是注定要发生或当前正在发生的。</span></div><br><div>2、如果风险没有得到有效的处理，就会变成问题。</div>

<p>二. 规范与流程</p>
<p>1. 规范化和流程化是对人的无秩序行为的一种制约.避免由人的无秩序行为导致不应出现的各种问题,节省由这种无秩序行为导致交互交流时间的浪费.</p>
<p>2. 团队的规范化流程化可以提升团队的战斗力,公司的规范化流程化可以形成整个公司的战斗力.</p>
<p>三. 代码审查</p>
<p>1. 通过审查代码能收获什么:</p>
<blockquote>
<p>a. 发现BUG.</p>
<p>b. 是一种社交途径.(如果你编程的时候就知道会有同事检查你的代码，那么你的程序会有所不 同–自检)</p>
<p>c. 知识分享</p>
</blockquote>
<p>2. 代码审查的误区与陷阱:</p>
<blockquote>
<p>a.&nbsp;<span lang="en-US">代码审查最重要规则是对即将提交的代码中查找问题——</span><span lang="zh-CN">你需要做的就是确认代码是正确的</span><span lang="en-US">。而通常会犯的一个错误，也是刚刚接触代码审查的新手容易犯的一个错误，即审阅者会判断这段代码是否按照自己思路来实现.</span></p>
<p><span lang="en-US">b.&nbsp;第二个误区就是人们感觉一定要说点什么（才算是做了代码审查）——不应该</span></p>
<p><span lang="en-US">c.&nbsp;第三个误区就是速度。你不应该匆忙完成一次代码审查——但是也不要拖延</span></p>
</blockquote>
<p>四. 有交流有分享才有进步,永远不要固步自封.</p>
<p>五. 在编写代码的时候,你要经常想着,那个最终维护你代码的人可能将是个有暴力倾向的疯子,并且他还知道你住哪儿</p>
<p>六. 用数据说话</p>
<p>七. 复杂的事情简单做，简单的事情重复做，重复的事情创新性的做</p>
<p>八.关于人才:</p>
<blockquote>
<p>【一个团队里，人分为五种】1.人渣,就是牢骚抱怨、无事生非，拉帮结派的人;2.人员,就是只领工资不爱做事，安排与自己无关的工作不愿干，属庸人之列;3.人手,就是安排什么做什么,不安排绝对不做;4.人才，就是发自内心做事，做事有责任、有思路、有条理，5.人物,一心要和企业做一番事业的人</p>
</blockquote>
<p>九. 与人合作的规则:做事的规则很重要,与人合作，矛盾迟早会有的。一开始就应该把决策机制和遇到矛盾大家怎么来协调定好,把坏的事情事先想好,不能依靠朋友间的友情来处理问题.这样是不会长久的.</p>
<p>&nbsp;</p>
<p>十. <span>生活工作中总有很多无奈,或因为角度,或因为认知;积极的心态才是应对一切的终极办法.</span></p>
<p>&nbsp;</p>
<p>十一. <span style="color:#ff0000">强大自己的五上习惯:</span></p>
<blockquote>
<p><span style="color:#ff0000">1.打败拖延:把让我不适的任务分解成众多的小事,制成表&#26684;记录进度.</span></p>
<p><span style="color:#ff0000">2.健身:有意识让自己不那么安逸.</span></p>
<p><span style="color:#ff0000">3.阅读:建立表&#26684;,细化计划,养成阅读习惯.</span></p>
<p><span style="color:#ff0000">4.早起:用自我奖励作为早起的吸引力,如提前准备好早点.</span></p>
<p><span style="color:#ff0000">5.写作:学会专注和组织语言表达想法.</span></p>
<p>&nbsp;</p>
</blockquote>
<p>&nbsp;十二. 阻塞,投诉,问题驱动与跟踪</p>
<p>&nbsp;</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/8/19 17:17:53 [原文链接](http://blog.csdn.net/kkaxiao/article/details/7883598)
&lt;/div&gt;
&lt;div&gt;
阅读：313 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/7883598#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/08/19/原-杂记/" data-id="cius3b9gv0002g4iff1b1joml" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-转-Core-Data-编程指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/05/23/转-Core-Data-编程指南/" class="article-date">
  <time datetime="2012-05-23T07:20:33.000Z" itemprop="datePublished">2012-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/05/23/转-Core-Data-编程指南/">[转]Core Data 编程指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div class="text_font" id="article_text_font"><br><br><span style="font-size:undefined"><strong>一、技术概览</strong></span><br><br><strong>1. Core Data 功能初窥</strong><br><br>&nbsp; 对于处理诸如对象生命周期管理、对象图管理等日常任务，Core Data框架提供了广泛且自动化的解决方案。它有以下特性。<br><br>&nbsp; （注：对象图－Object graph的解释：在面向对象编程中，对象之间有各种关系，例如对象直接引用另外的对象，或是通过引用链间接的引用其他对象，这些关系组成了网状的结构。我们把这些对象（和它们之间的联系）成为对象图。 对象图可大可小，有繁有简。 只包含单个字符串对象的数组就是一个简单的代表；而包含了application对象，引用windows， menus和相关视图对象、其他对象这样的结构就是复杂对象图的例子——这是在说mainwindow.xib。<br><br>&nbsp;&nbsp;&nbsp; 有时，你可能想要把这样的对象图转化形式，让它们可以被保存到文件中，以使其他的进程或其他的机器可以再次将保存的内容读出，重购对象。 这样的过程常被成之为“归档”(Archiving)。<br><br>&nbsp;&nbsp;&nbsp; 有些对象图是不完整的——通常称之为局部对象图（partial object graphs）。局部对象图包含了“占位符”（Placeholder）对象，所谓”占位符“，就是一些暂时无内容的对象，它们将再后期被具体化。一个典型的例子就是nib文件中包含的File’s Owner对象。<br><br>&nbsp; 1) 对于key-value coding 和key-value observing完整且自动化的支持<br><br>除了为属性整合KVC和KVO的访问方法外， Core Data还整合了适当的集合访问方法来处理多&#20540;关系。<br><br>&nbsp; 2) 自动验证属性(property)&#20540;<br><br>Core Data中的managed object扩展了标准的KVC 验证方法，以保证单个的数&#20540;在可接受的范围之内，从而使组合的&#20540;有意义。（需校准翻译）<br><br>&nbsp; 3) 支持跟踪修改和撤销操作<br><br>对于撤销和重做的功能，除过用基本的文本编辑外，Core Data还提供内置的管理方式。<br><br>&nbsp; 4) 关系的维护<br><br>Core Data管理数据的变化传播，包括维护对象间关系的一致性。<br><br>&nbsp; 5) 在内存中和界面上分组、过滤、组织数据<br><br>&nbsp; 6) 自动支持对象存储在外部数据仓库的功能<br><br>&nbsp; 7) 创建复杂请求<br><br>你不需要动手去写复杂的SQL语句，就可以创建复杂的数据请求。方法是在“获取请求”(fetch request)中关联NSPredicate（又看到这个东东了，之前用它做过正则）。NSPrdicate支持基本的功能、相关子查询和其他高级的 SQL特性。它还支持正确的Unicode编码（不太懂，请高人指点）， 区域感知查询（据说就是根据区域、语言设置调整查询的行为）、排序和正则表达式。<br><br>&nbsp; 8) 延迟操作（原文为Futures(faulting）直译为期货，这里个人感觉就是延迟操作的形象说法。请高人指教)。<br><br>Core Data 使用延迟加载(lazy loading)的方式减少内存负载。 它还支持部分实体化延迟加载，和“写时拷贝”的数据共享机制。（写时拷贝，说的是在复制对象的时候，实际上不生成新的空间，而是让对象共享一块存储区域，在其内容发生改变的时候再分配）。<br><br>&nbsp; 9) 合并的策略<br><br>Core Data 内置了版本跟踪和乐观锁定(optimistic locking)来支持多用户写入冲突的解决。<br><br>注：乐观锁，假定数据一般不出现冲突，所以在数据提交更新的时候，才对数据的冲突进行检测，如果冲突了，就返回冲突信息。<br><br>&nbsp; 10) 数据迁移<br><br>就开发工作和运行时资源来说，处理数据库架构的改变总是很复杂。Core Data的schema migration工具可以简化应对数据库结构变化的任务， 而且在某些情况下，允许你执行高效率的数据库原地迁移工作。<br><br>&nbsp; 11) 可选择针对程序Controller层的集成，来支持UI的显示同步<br><br>Core Data在iPhone OS之上 提供NSFetchedResultsController对象来做相关工作，在Mac OS X上，我们用Cocoa提供的绑定(Binding)机制来完成。<br><br><strong>2. 为何要使用Core Data</strong><br><br>&nbsp;&nbsp;&nbsp; 使用Core Data有很多原因，其中最简单的一条就是：它能让你为Model层写的代码的行数减少为原来的50％到70%。 这归功于之前提到的Core Data的特性。更妙的是，对于上述特性你也既不用去测试，也不用花功夫去优化。<br><br>&nbsp;&nbsp;&nbsp; Core Data拥有成熟的代码，这些代码通过单元测试来保证品质。应用Core Data的程序每天被世界上几百万用户使用。通过了几个版本的发布，已经被高度优化。 它能利用Model层的信息和运行时的特性，而不通过程序层的代码实现。 除了提供强大的安全支持和错误处理外，它还提供了最优的内存扩展性，可实现有竞争力的解决方案。不使用Core Data的话，你需要花很长时间来起草自己的方案，解决各种问题，这样做效率不高。<br><br>&nbsp;&nbsp;&nbsp; 除了Core Data本身的优点之外，使用它还有其他的好处： 它很容易和Mac OS X系统的Tool chain集成；利用Model设计工具可以按图形化方式轻松创建数据库的结构；你可以用Instruments的相关模板来测试Core Data的效率并debug。 在Mac OS X的桌面程序中，Core Data还和Interface Builder集成（打开Inspector可以看到有binding的选项，这个东东iPhone上木有。。。），按照model来创建UI变的更简单了。 这些功能能更进一步的帮助你缩短设计、开发、测试程序的周期。<br><br><strong>3. Core Data不是。。。</strong><br><br>&nbsp;&nbsp;&nbsp; 看了前面的介绍之后，我们还需要了解一下关于Core Data常见的误解：<br><br>&nbsp; 1) Core Data不是一个关系型数据库，也不是关系型数据库管理系统(RDBMS)。<br><br>Core Data 为数据变更管理、对象存储、对象读取恢复的功能提供了支持。 它可以使用SQLite作为持久化存储的类型。 它本身并不是一个数据库（这点很重要，比如，你可以使用Core Data来记录数据变更，管理数据，但并不能用它向文件内存储数据）。<br><br>&nbsp; 2) Core Data不是银弹<br><br>它并不能取代你写代码的工作。虽然可以纯粹使用XCode的数据建模工具和Interface Builder来编写复杂程序，但在更多的程序中，你都自己动手写代码。<br><br>&nbsp; 3) Core Data并不依赖于Cocoa Bindings<br><br>Core Data &#43; Cocoa Binding ＝ 减少代码数量。但Core Data完全可以在没有bindings的条件下使用。例如，可以编写一个没有UI，但包含Core Data的程序。<br><br><span style="font-size:undefined"><strong>二、Core Data基础</strong></span><br><br><strong>1. Core Data基本架构</strong><br><br>&nbsp;&nbsp;&nbsp; 在大部分程序中，你要能通过某种方式打开一个包含对象归档的文件， 这个文件内至少要有一个根对象的引用。另外，还得能将所有的对象归档到文件中，如果你想要实现撤销的功能，就还要记录对象的更改情况。例如，在 Employee的示例程序中，你要能打开一个包含有employee和department对象归档的文件，而且这个文件至少包含了一个根对象——这 里，是一个包含所有employee的数组——请参考例图Figure 1。 相应的，你还要能将程序中的employee、department对象归档到文件中去。<br><br>Figure 1 按照Core Data文档结构管理的对象示意图<br><br><span id="att_15503"><br><br><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/1605221933-0.gif" alt=""></span><br><br>&nbsp;&nbsp;&nbsp; 使用Core Data的框架，大多数的功能都可以自动实现，因为我们有managed object context（管理对象的上下文，有时直接叫&quot;Context&quot;）。managed object context就像是一个关卡，通过它可以访问框架底层的对象——这些对象的集合我们称之为&quot;persistence stack&quot;（数据持久栈）。 managed object context作为程序中对象和外部的数据存储的中转站。栈的底部是persistence<br> object stores（持久化数据存储），请看Figure 2的示意图。<br><br><span id="att_15500"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/16052262c-1.gif" alt=""></span><br><br>Figure 2 使用Core Data的文档管理示意图<br><br>&nbsp;&nbsp;&nbsp; Core Data的使用并不限制在基于文档的程序中（document-based application）。你也能创建一个包含Core Data 的Utility程序（请查看Core Data Utility tutorial文档）。当然其他类型的程序也都可以使用Core Data。<br><br><strong>被管理对象和上下文(Managed Objects and Contexts)</strong><br><br>&nbsp;&nbsp;&nbsp; 你可以把被管理对象上下文想象成一个”聪明“的便笺簿。当你从数据持久层获取对象时，就把这些临时的数据拷贝拿到写在自己的便笺簿上（当然，在便笺上对象会 “恢复”以前的对象图结构）。然后你就可以随心所欲的修改这些&#20540;了（本子是你的，随便画都可以），除非你保存这些数据变化，否则持久层的东西是不会变 的。（跟修改文件后要保存是一个道理）。<br><br>&nbsp;&nbsp;&nbsp; 附在Core Data框架中模型对象（Model objects）常被称为“被管理对象”(Managed objects)。所有的被管理对象都要通过上下文进行注册。使用上下文，你可以在对象图中添加、删除对象，并记录对象的更改（包括单个对象，或是对象间 的关系）。记录更改后就能支持撤销和重做的功能。同时，上下文还能保证关系更改后对象图的完整性。<br><br>&nbsp;&nbsp;&nbsp; 如果你想要保存所做的修改， 上下文会保证对象的有效性。在验证有效性后，更改会被写入到persistent store(持久化存储层)中。你在程序中的添加和删除动作都会被作用在存储的数据中。<br><br>&nbsp;&nbsp;&nbsp; 在你的一个程序中，可能存在多个上下文。 对于数据存储(store)中的每个对象，对应的都有唯一的一个被管理对象(managed object)和上下文相关联（详情请查看&quot;Faulting and Uniquing&quot;文档）。换个角度来想，在persistent store中存储的对象有可能被用在不同的上下文中，每个上下文都有与之对应的被管理对象，被管理对象可以被独立的修改，这样就可能在存储 时导致数据的不一致。Core Data提供了许多解决这个问题的途径（请查看&quot;Using<br> Managed Object&quot;一章）。<br><br><strong>获取数据的请求(Fetch Requests)</strong><br><br>&nbsp;&nbsp;&nbsp; 要使用上下文来获取数据，你需要创建相应的请求(Fetch request)。 Fetch request对象包含你想获取的对象的描述。例如：“所有 Employee”，或“所有的Employee，department是marketing，按薪资降序排列”。Fetch Request包含三个部分。使用最简单的写法，必须指定实体（Entity）的名称，这就暗示了，每次智能获得一种类型的实体。 Fetch Request 还可以包含谓词（predicate）——注：有些地方也把这个叫断言，个人感觉谓词更准确些。谓词将描述对象需要满足的条件（这就和我们在SQL里加的<br> 限定条件差不多，正如前面的&quot;All Employees, in the Marketing department&quot;）。另外，Fetch Request还可包含一个用于描述排序方式的对象（熟悉的Order by操作）。如图Figure3所示：<br><br><span id="att_15502"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/16052213M-2.gif" alt=""></span><br><br>&nbsp;&nbsp;&nbsp; 在程序中，你将Fetch Request这个请求发送给上下文，上下文就会从相关的数据源中查找复合条件的对象（也可能找不到），并返回。 所有的被管理对象（managed object）都必须在上下文中注册，因此通过fetch request获得的对象自动被注册。但如前所述，每个在持久存储层（persistence store）中的对象都对应一个和上下文相关的被管理对象(managed object)，因此，如果在上下文中已经存在了fetch request要取的对象，那么这个被管理对象将被返回。<br><br>&nbsp;&nbsp;&nbsp; Core Data追求高执行效率。 它是“需求驱动”的，因此只会创建你确实需要的对象。对象图不需要保留所有在数据存储层中的对象。单纯指定数据持久层的动作不会将其中所有的数据放到上下 文中去。 当你想从数据存储层中获取某些对象的时候，你只会得到那些你请求的（有点罗嗦，总的意思就是需要时获取，获取的就是需要的）。如果你不在需要这个对象的时 候，默认情况下它会被释放。（当然，只是释放这个对象，而不是从对象图中移除该对象）。——注：个人感觉有点像重新拷了一个文件的某些部分，不用了就在副<br> 本中删除，不会影响原件。<br><br><strong>持久化存储助理(Persistent Store Coordinator)</strong><br><br>&nbsp;&nbsp;&nbsp; 之前提到过，程序中的对 象和外部存储的数据通过Core Data框架中的一系列对象进行协调，这一系列的对象总的被称为持久存储栈(Persistence stack)。在栈顶是被管理对象上下文(Managed object context)，而栈底是持久化对象存储层(Persistence object store)。在它们之间就是持久化存储助理。<br><br>&nbsp;&nbsp;&nbsp; 事实上，持久化存储助理定义了一个栈。从设计方面考虑，它就是可以作为上下 文的”外观“， 这样多个数据存储(Persistence store)看起来就像是一个。 然后上下文就可以根据这些数据存储来创建对象图了。持久化存储助理智能关联一个被管理对象的模型。如果你像要把不同的实体放到不同的存储中去，就需要为你 的模型实体做“分区”，方式是通过定义被管理对象模型的configurations。（请参考&quot;Configurations&quot;一章）。<br><br>&nbsp;&nbsp;&nbsp; Figure 4演示了这样的一个结构：employees和departments存储在一个文件中，customers和companies存储在另外一个文件中。当你要获取对象的时候，它们从相关的文件中自动获取；当保存时，又被归档到相应的文件中。<br><br>Figure 4存储栈—改<br><br><span id="att_15501"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/16052242J-3.gif" alt=""></span><br><br><strong>持久化存储(Persistent Stores)</strong><br><br>&nbsp;&nbsp;&nbsp; 持久化存储是和单独的一个文件或外部的数据关联的，它负责将数据和上下文中的对象进行对应。通常，需要你直接和持久化对象存储打交道的地方，就是指定新的、 和程序进行关联的外部数据的位置（例如，当用户打开或保存一个文档）。大多数需要访问持久化存储的动作都由上下文来完成。<br><br>&nbsp;&nbsp;&nbsp; 程序的代码—— 特别是和被管理对象相关的部分——不应该对持久化存储做任何假设（也就是不需要自己考虑存储的方式或过程）。 Core Data对几种文件&#26684;式有原生的支持。你可以选择一种自己程序需要的。假设在某个阶段你决定换一种文件的&#26684;式，而又不想修改程序的框架，而且，你的程序做 了适当的抽象（注：这个就属于设计方面的东东了），这时，你就能尝到使用Core Data的甜头了。例如，在最初的设计中，程序只从本地文件中获取数据，而你的程序没有去硬指定对应数据的获取位置，而是可以在后期指定从远程位置添加新<br> 的数据类型，这样你就可以使用新的类型，而不需要修改代码。（这段还是感觉翻的不太合适）。<br><br><strong>重要提示：</strong><br><br>&nbsp;&nbsp;&nbsp; 虽然Core Dta支持SQLite作为一种存储类型，但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。（详情，请参考&quot;Persistence Store Features&quot;）。<br><br><strong>持久化文档（Persistent Documents）</strong><br><br>&nbsp;&nbsp;&nbsp; 你可以通过代码的方式创建和配置持久存储栈，但在多数情况下，你只是想创建一个基于文档 的应用程序（Document-based application，这个是mac上的）来读写文件。这时，用NSDocument的子类NSPersistentDocument可以让你感受到使 用Core Data的便利。默认状况下，NSPersistentDocument就已经创建了它自己的持久存储栈，其中包含了上下文，和单个的持久对象存储，来处 理这样文档和外部数据“一对一”的映射关系。<br><br>&nbsp;&nbsp;&nbsp; NSPersistentDocument类提供了访问文档的上下文的方法，也实现了标准的NSDocument方法来通过Core Data读写文件。 一般说来，你不需要编写额外的代码来处理对象的持久化。<br><br>&nbsp;&nbsp;&nbsp; 持久化文档的撤销（undo）操作也被集成在被管理对象的上下文中。<br><br>&nbsp;&nbsp;&nbsp; 被管理对象和被管理对象模型（Managed Objects and the Managed Object Model）<br><br>为 了管理对象图，也为了提供对象持久化的功能，Core Data需要对对象有很强的描述能力。被管理对象模型就是程序中对象、实体描述的概要图，如图Figure 5所示。创建模型的常用做法是通过Xcode的图形化建模工具Date Model Design tool。但是如果你愿意的话，也可以在运行时通过代码来建模。<br><br>Figure 5 有两个实体的对象模型<br><br><span id="att_15939"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/1605224646-4.gif" alt=""></span><br><br>&nbsp;&nbsp;&nbsp; 模型由多个实体描述对象构成，每个描述提供实体的某项元数据，它们包含实体名、实体在程序中的类名（当然，类名和实体名不需要一致）、属性还有关系。属性和关系依次被属性和关系描述对象所代表，如图Figure 6所示。<br><br>Figure 6 带有两个属性和一个关系的的实体描述<br><br><span id="att_15938"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/16052243U-5.gif" alt=""></span><br><br>&nbsp;&nbsp;&nbsp; 被管理对象必须是NSManagedObject或其子类的实例。 NSManagedObject可用来表示任何实体。它使用内部私有的存储机制来维护自身的属性，并执行一个被管理对象所必须的基本操作。一个被管理对象 拥有一份实体描述的引用。在使用时，它通过实体描述来找到自身的元数据，包括实体名和属性、关系的信息。你也可以继承NSManagedObject来执 行额外的操作。<br><br><strong>被管理对象模型（Managed Object Models）</strong><br><br>&nbsp;&nbsp;&nbsp; 多数Core Data的功能依赖于你创建的，用来描述程序的实体及其属性、关系的模型图。 模型图由NSManagedObjectModel所表示。一般说来，模型的信息越充实，Core Data能提供的功能就越好。 下文讲解了对象模型的特性，以及如何在程序中创建、使用对象模型。<br><br><strong>被管理对象模型的特性</strong><br><br>&nbsp;&nbsp;&nbsp; 被管理对象模型是 NSManagedObjectModel的实例。它描述了你在程序中使用的实体的概要信息。（如果读者不了解entity、property、 attribute和relationship的含义，请先查看&quot;Core Data Basics&quot;和&quot;Cocoa Design Patterns&quot;文档中的&quot;Object Modeling&quot;一节）<br><br><strong>实体（Entities）</strong><br><br>&nbsp;&nbsp;&nbsp; 模型包含了NSEntityDescription对象，NSEntityDescription对象指代了模型的实体。关于实体由两个重要特征：名称（name）和类名（name of class）。你应该弄清楚实体、实体的类和作为实体实例的被管理对象之间的区别。<br><br>&nbsp;&nbsp;&nbsp; NSEntityDescription 对象可包含NSAttributeDescription对象（指代实体的attribute）和NSRelationshipDescription对 象（指代实体间的relationship）。实体也可能包含fetched属性，该属性由NSFetchedPropertyDescription指 代，模型中有对应的fetch请求的模板，fetch请求由NSFetchRequest所指代。<br><br><strong>实体的继承关系</strong><br><br>&nbsp;&nbsp;&nbsp; 实体的继承和类 的继承很类&#20284;，当然，也同样有用。 如果你有若干个相&#20284;的实体，就可以抽离出它们的共有特性作为一个“父实体”，就省去了在多个实体中都指定相同的属性。 例如，你可以定义一个包含firstName和lastName的“Person”实体，然后在定义子实体&quot;Employee&quot;和&quot;Customer&quot;。<br><br>&nbsp;&nbsp;&nbsp; 如果是使用Xcode的可视化建模工具来创建模型，你就可以通过如下图的方式为一个实体指定父级实体。<br><br>Figure1 Xcode中为一个实体指定父实体<br><br><span id="att_15940"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/160522G62-6.gif" alt=""></span><br><br>&nbsp;&nbsp;&nbsp; 如果你想在代码中创建继承关系。就需要自顶向下来执行。不能直接指定实体的父实体，而只能给一个实体指定子实体（使用setSubentities:）。这 就是说，如果你想给A实体指定父实体，就只能把A作为数组中的一个元素，调用目标父实体setSubentities:的方式来设置。<br><br><strong>抽象实体</strong><br><br>&nbsp;&nbsp;&nbsp; 你可以把一个实体指定为“抽象实体”，也就是说，你不打算使用这个实体来创建实例。通常，当你想把这个实体作为父实体，而有子实体来实现详细内容的时候，就 把它声明“抽象实体”。（和抽象类很像）。例如，在一个绘图程序中，你可能会设计一个Graphic实体，它包含了x和y坐标信息、颜色、绘制区域，而你 不会去创建一个Graphic的实例，而是使用具体的子实体——Circle、TextArea、Line。（这些基本的东西就不给大牛们再罗嗦 了。。。）<br><br><strong>Properties（属性，这个和Attributes的意思一样，实在区别不出来，只好上英语了）</strong><br><br>&nbsp;&nbsp;&nbsp; 实体的 Properties是它的attributes和relationship，包含了fetched属性（如果有的话）。每个property都有名称和 类型。 Attribute也可能有默认&#20540;。property的名称不能和NSObject和NSManagedObject类中的无参方法名相同。例如，不能把 property命名为&quot;description&quot;。<br><br>&nbsp;&nbsp;&nbsp; 临时属性（Transient Property）也是作为模型的一部分，但是不作为实体实例的数据保存在持久存储层。 Core Data也会跟踪临时属性的变化，以备撤销操作时使用。<br><br>&nbsp;&nbsp;&nbsp; 注意：如果你用模型外的信息对临时属性执行撤销操作，Core Data将不会使用旧&#20540;，调用你的set方法——它只会更新快照信息（snapshot information）。（这段怪怪的，用到的话在修改一下翻译吧）<br><br><strong>Attributes</strong><br><br>&nbsp;&nbsp;&nbsp; Core Data内部支持各种attribute的类型，例如string，date，integer（NSString, NSDate, NSNumber）。如果你使用那些不支持的数据，你需要用到在“Non-Standard Persistent Attributes”介绍到的技术。<br><br>&nbsp;&nbsp;&nbsp; 你可以将一个attribute声明为“可选”（optional），可选的attribute不 必须有&#20540;，但是，不鼓励你将属性置空——尤其是数字&#20540;（更好的解决方案是使用强制的&#20540;，在这里，我们用默认&#20540;，例如0）。 这样做的原因是为了配合SQL中对于空&#20540;NULL做比较的操作：NULL不同于Objective-C中的nil。 数据库中的NULL不同于0，搜索0&#20540;的操作不会匹配到&#20540;为NULL的列。<br><br>false == (NULL == 0)<br><br>false == (NULL != 0)<br><br>&nbsp;&nbsp;&nbsp; 而且，在数据库中，NULL也不等于空字符串或是空的数据对象：<br><br>false == (NULL == @&quot;&quot;)<br><br>false == (NULL != @&quot;&quot;)<br><br>&nbsp;&nbsp;&nbsp; 它们之间一点关系都没有。<br><br><strong>关系（Relationships）</strong><br><br>&nbsp;&nbsp;&nbsp; Core Data支持对一、对多的关系，也支持fetched属性。 Fetched property表示了一种“弱”的、单项的关系。 在employees和departments的例子中， department 的一个fetched property可能是“最近雇佣人”（recent hires），而反过来，employee不会拥有这样的关系。<br><br><strong>获取数据请求的模板（Fetch Request Templates）</strong><br><br>&nbsp;&nbsp;&nbsp; 我们使用NSFetchRequest类来描述数据请求，利用数据请求从持久存储（persistent store）中获取对象。 经常需要多次执行同样的请求，或是执行某种模式的请求，但是其中包含可变的元素（如查找条件）——这些元素经常有用户提供。 例如，在运行的时候，你要根据用户需要获取某个作者在某个指定日期后的出版的所有出版物。<br><br>&nbsp;&nbsp;&nbsp; 你可以预定义请求，把它们作为模板存储在被管理对象模型中。 预定义的模板在你需要的时候就可以取出使用。通常情况下，我们通过Xcode的data modeling tool工具创建请求模板。模板可以包含变量，如图Figure 2所示。<br><br>Figure 2&nbsp;&nbsp;Xcode predicate builder<br><br><span id="att_15941"><img src="http://www.cocoachina.com/cms/uploads/allimg/101126/16052224P-7.gif" alt=""></span><br><br><span>&nbsp;&nbsp;&nbsp; 关于Fetch request templates的详细信息，请查看&quot;Accessing and Using a Managed Object Model at Runtime&quot;的描述。</span><br><br><strong><span>用户信息字典（User Info Dictionaries）</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 模型中的许多元素，诸如entities, attributes, relationships，都有相关的用户信息字典。用熟悉的键－&#20540;对，你可以向其中放置任何你需要的数据。这里常用的信息有实体的版本详情，还有针对 fetched property，给谓词（predicate）用的&#20540;。</span><br><br><strong><span>配置（Configurations）</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 配置包含了一个名称和若干个相关的实体。实体的集合是可以重叠的——这就是说，一个实体可以出现在多个配置中。在代码中，我们使用setEntities: forConfiguration:的方法来指定配置。也可以用Xcode的建模工具来指定（选中某个实体，就在属性窗口的第三个，就是一个小扳手的符号）。要获取某项配置的实体，需要用entitiesForConfiguration:的方法。</span><br><br><span>&nbsp;&nbsp;&nbsp; 一般说来，如果你想把不同的实体存放在不同的存储中去，就可能用到配置。一个持久化存储助理（persistent store coordinator）只能有一个被管理对象模型。所以，默认情况下，和助理关联的某个存储必须包含同样的实体。要想绕过这个限制，你可以创建一个包含实体子集的模型，然后为每一个子集创建配置，这样一来，使用这个模型创建助理，当你需要添加存储时，可使用不同的配置指定对应的存储属性。当你创建配置的时候，需要记住，不能创建跨存储的关系。</span><br><br><strong><span>使用被管理对象模型</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 通常可以使用Xcode的建模工具来创建模型（请参考&quot;Create a managed object with Xcode&quot;）。你也可以全部使用代码来创建（请参考&quot;Core Data Utility Tutorial&quot;）。</span><br><br><strong><span>编译数据模型</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 数据模型是一种部署资源。 在模型中，除了有实体和属性的详细信息外，用Xcode创建的模型还包含了一些额外的视图信息，包括布局、颜色等等。这些信息在运行时不是必须的。模型文件在编译的过程中会删除这些额外信息以保证尽可能高效的加载。xcdatamodel“源”文件会被momc编译器编译为mom的目标文件。</span><br><br><span>&nbsp;&nbsp;&nbsp; &quot;mom&quot; 位于 /Library/Application Support/Apple/Developer Tools/Plug-ins/XDCoreDataModel.xdplugin/Contents/Resources/，如果你想把它用在自己的 build脚本中，&#26684;式是：mom source destination， source 就是Core Data Model文件，destination就是输出的mom文件。</span><br><br><strong><span>加载数据模型</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 在一些情况下，你不需要写任何加载模型的代码。如果你使用基于文档的程序框架（Document-based application），NSPersistentDocument会管理诸如查找模型、加载模型的任务。 如果你创建了非Document-based application，而且里面又用到了Core Data，一般将获取模型的代码放在application delegate里。模型的存储名称——也就是文件名，</span><br><br><span>&nbsp;&nbsp;&nbsp; 和运行时的名称是不相关的，一旦模型被加载，文件名就没有什么意义了。也就是说，对模型文件，你可以随意命名。</span><br><br><span>&nbsp;&nbsp;&nbsp; 如果你想手动加载模型，有两种方式可用，它们各有各的好处：</span><br><br><span>&nbsp;&nbsp;&nbsp; 你可以从指定的bundle集合里创建整合模型，使用如下的类方法：<br><br>mergeModelFromBundles:</span><br><br><span>&nbsp;&nbsp;&nbsp; 也可以用指定的URL加载单个的模型，使用如下的实例方法：<br><br>initWithContentsOfURL: （这个方法相信大家都用过）</span><br><br><span>&nbsp;&nbsp;&nbsp; 若不需要考虑分开加载模型，第一个类方法很适用。例如：在你的程序中和程序链接的framework里都有你想要加载的模型。这个类方法可以让你很轻松的加载所有的模型，而不需要考虑模型文件的名称，也不用特定的初始化方法来保证所有的模型都被找到。</span><br><br><span>&nbsp;&nbsp;&nbsp; 但是当你有多个模型要加载，特别是这些模型都代表了一个schema的不同版本，这时，知道要加载哪个模型就很重要了（合并包含相同实体的模型可能导致命名冲突和错误，我们之前“一锅端”的方法不太合适了）。在这种情况下，我们可以用第二个实例方法。 另外，有时我们也需要将模型存储在bundle之外，也需要用这个方法从指定的URL位置加载模型。</span><br><br><span>&nbsp;&nbsp;&nbsp; 还有一点需要说明：我们还有一个类方法 modelByMergingModels:可以用。像mergedModelFromBundles:方法一样，它也能合并给定的若干个模型。这样，我们就可以通过URL来逐一加载模型，然后在创建助理对象之前将它们整合为一个。</span><br><br><strong><span>改变模型</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 由于模型描述了存储层数据的结构，任何改变模型的动作都将使其不在适配于之前创建的存储层。 如果你改变了模型的结构，就需要将当前存储层的数据迁移到新版本。（请参考&quot;Core Data Model Versioning and Data Migration Programming Guide&quot;文档）。例如：如果你添加了新的实体，或新的属性，你将无法打开旧的存储；如果你添加了验证的限制，或者为属性添加了新的缺省&#20540;，你就可以打开旧的存储。</span><br><br><strong><span>在运行时访问和适用被管理对象模型</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 在运行时，被管理对象模型就是一个简单的“对象图”（这个概念之前提到过），认识到这点很重要，尤其是当你需要用代码来访问模型的详细信息时。例如：修改模型（你只能在runtime之前这样做，请参考 NSManagedObjectModel），取回信息（如本地化实体名，属性数据类型，或数据请求模板）。</span><br><br><span>&nbsp;&nbsp;&nbsp; 在运行时访问模型有很多方法，通过持久栈最终从持久化存储助理得到模型，代码如下：<br><br><span style="color:#339966">[[aManagedObjectContext persistentStoreCoordinator]managedObjectModel];</span></span><br><br><span>&nbsp;&nbsp;&nbsp; 你也可以通过实体描述得到模型，因此给定一个被管理对象，你就可以得到它的实体描述，进而获得模型。代码如下：<br><br><span style="color:#339966">[[aManagedObject entity] managedObjectModel];</span></span><br><br><span>&nbsp;&nbsp;&nbsp; 某些情况下，你要维护模型的“直接”引用，也就是说，一个直接返回模型的方法。NSPersistentDocument提供了 managedObjectModel方法，可以返回一个模型，该模型和在文档的上下文中使用的持久化存储助理相关联。如果你使用Core Data Appplication的模板，application delegate将负责模型的引用。</span><br><br><strong><span>通过代码创建获取数据请求模板（Fetch Request Templates）</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 你可以通过代码创建数据请求模板并将其和模型关联，方法是：setFetchRequestTemplate: forName:如Listing-1所示。 提醒一下：你只能在模型被助理（coordinator）使用之前修改它。</span><br><br><span>&nbsp;&nbsp;&nbsp; Listing 1 通过代码创建获取数据请求模板</span><br><br><span style="color:#339966"><span>NSManagedObjectModel <em>model = …;<br><br>NSFetchRequest </em> requestTemplate = [[NSFetchRequest alloc]init];<br><br>NSEntityDescription <em>publicationEntity =<br><br>&nbsp;&nbsp;&nbsp; [[model entitiesByName] objectForKey: @&quot;Publication&quot;];<br><br>[requestTemplate setEntity: publicationEntity];<br><br>NSPredicate </em>predicateTemplate = [NSPredicate predicateWithFormat:<br><br>&nbsp;&nbsp;&nbsp; @&quot;(mainAuthor.firstName like[cd] $FIRST_NAME) AND \<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (mainAuthor.lastName like[cd] $LAST_NAME) AND \<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (publicationDate &gt; $DATE)&quot;];<br><br>[requestTemplate setPredicate: predicateTemplate];<br><br>[model setFetchRequestTemplate: requestTemplate<br><br>&nbsp;&nbsp;&nbsp; forName: @&quot;PublicationForAuthorSinceDate&quot;];<br><br>[requestTemplate release];</span></span><br><br><strong><span>访问请求模板</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 你可以用&quot;Accessing and Using a Managed Object Model at Runtime&quot;里介绍的代码片段来获取并使用请求模板。替换字典必须包含和模板中定义的变量对应的键。如果你想测试null&#20540;，必须使用NSNull对象——参考&quot;Using Predicates&quot;。（注：这里的替换字典很好理解，之前的模板中用到了诸如$FIRST_NAME, $LAST_NAME, $DATE这些东西，就相当于我们在模板中创建好的“变量”，我们需要把一个模板“具体化”，就用替换字典，将里面的变量对应一个&#20540;，这里看代码就明白了。）</span><br><br><span style="color:#339966"><span>NSManagedObjectModel <em>model = …;<br><br>NSDictionary </em>substitutionDictionary = [NSDictionary dictionaryWithObjectsAndKeys:<br><br>&nbsp;&nbsp;&nbsp; @&quot;Fiona&quot;, @&quot;FIRST_NAME&quot;, @&quot;Verde&quot;, @&quot;LAST_NAME&quot;,<br><br>&nbsp;&nbsp;&nbsp; [NSDate dateWithTimeIntervalSinceNow: -31356000], @&quot;DATE&quot;, nil]; //这里的FIRST_NAME, LAST_NAME, DATE和我们之前模板里的$FIRST_NAME, $LAST_NAME和$DATE对应<br><br>NSFetchRequest <em>fetchRequest =<br><br>&nbsp;&nbsp;&nbsp; [model fetchRequestFromTemplateWithName: @&quot;PublicationForAuthorSinceDate&quot;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; substitutionVariables: substitutionDictionary]; //从之前的model中拿出请求模板，然后设定替换字典<br><br>NSArray </em>results =<br><br>&nbsp;&nbsp;&nbsp; [aManagedObjectContext executeFetchRequest: fetchRequest error: &amp;error];</span></span><br><br><span>&nbsp;&nbsp;&nbsp; 要是模板里不包含可替换的变量，你要么</span><br><br><span>1. 使用fetchRequestFromTemplateWithName: substitutionVariables: 方法，传递nil给第二个参数<br><br>或者：<br><br>2. 使用fetchRequestTemplateForName: 并将结果copy。这个方法不需要传递“替换变量”这个参数，但是如果你要用返回&#20540;本身，将会有异常抛出（无法在不可变的模型中修改命名的数据请求&quot;Can’t modify named fetch request in an immutable model&quot;）。</span><br><br><strong><span>本地化被管理对象模型</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 你可以对模型的大部分内容做本地化处理，包括实体和属性名，还有错误信息。要明白，“转成你自己的语言”也是本地化的一部分。 即使你不打算提供外语版本， 显示“自然语言”的出错提示信息也会有更好的用户体验。例如：“First Name is a required property”就比&quot;firstName is a required property&quot;更好。（后面的这个更像是开发者用的log，显示的是变量名，这里不太明显）。</span><br><br><span>&nbsp;&nbsp;&nbsp; 要想对模型进行本地化处理，需要提供一个本地化字典，模式如下：</span><br><br><span>&nbsp;&nbsp;&nbsp; Table 1 针对被管理对象模型的本地化字典键&#20540;对应关系：</span><br><br><span>Key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note<br><br>&quot;Entity/NonLocalizedEntityName&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LocalizedEntityName&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&quot;Property/NonLocalizedPropertyName/Entity/EntityName&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LocalizedPropertyName&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br><br>&quot;Property/NonLocalizedPropertyName&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LocalizedPropertyName&quot;<br><br>&quot;ErrorString/NonLocalizedErrorString&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;LocalizedErrorString&quot;</span><br><br><span>&nbsp;&nbsp;&nbsp; 备注：(1)在不同实体中的属性，拥有相同的原始名称，但需要不同的本地化名称，适用于该&#26684;式。</span><br><br><span>&nbsp;&nbsp;&nbsp; 我们可以通过localizationDictionary方法来访问本地化字典。注意：在Mac OS X 10.4上，这个方法可能返回nil，除了Core Data为了某些特定目的（如报告本地化的错误描述）延迟加载本地化字典。</span><br><br><strong><span>字符串文件</span></strong><br><br><span>&nbsp;&nbsp;&nbsp; 处理模型的本地化最简单的方法就是创建对应的字符串文件——字符串文件名和模型文件名一直，但是后缀名用.strings。（例如，模型文件名为 MyDocument.xcdatamodel，对应的字符串文件名就为MyDocumentModel.strings；如果模型文件已经包含了 Model后缀，你必须再附加一个Model，所以，如果模型文件名为JimsModel.xcdatamodel对应的字符串文件名为 JimsModelModel.strings）。字符串文件&#26684;式和标准字符串文件类&#20284;（请参考&quot;Localizing<br> String Resources&quot;），但是对应的键&#20540;要遵循Table-1中的规则。</span><br><br><span>&nbsp;&nbsp;&nbsp; 一个模型的字符串文件实例：</span><br><br><span>&quot;Entity/Emp&quot; = &quot;Employee&quot;;<br><br>&quot;Property/firstName&quot; = &quot;First Name&quot;;<br><br>&quot;Property/lastName&quot; = &quot;Last Name&quot;;<br><br>&quot;Property/salary&quot; = &quot;Salary&quot;;</span><br><br><span>&nbsp;&nbsp; 更详细的示例请参考&quot;NSPersistentDocument Core Data Tutorial&quot;。</span><br><br><strong><span>代码实现设置本地化字典</span>

</strong><br><br><span>&nbsp;&nbsp;&nbsp; 你可以在运行时设定本地化字典，适用NSManagedObjectModel的setLocalizationDictionary:方法即可。你必须创建一个符合Table-1&#26684;式的字典，并把它和模型关联。必须保证在模型被使用（获取或创建被管理对象）之前做这些工作，因为再使用后模型就不可编辑了。 Listing 3演示了创建包含本地化字典的被管理对象模型。实体名称叫“Run”，它有两个属性： &quot;date&quot;和&quot;processID&quot;，分别是date和integer类型。process<br> ID的&#20540;不能为负。</span><br><br><strong><span>Listing 3 通过代码创建被管理对象模型</span></strong><br><br><span>NSManagedObjectModel <em>mom = [[NSManagedObjectModel alloc] init];<br><br>NSEntityDescription </em>runEntity = [[NSEntityDescription alloc] init];<br><br>[runEntity setName:@&quot;Run&quot;];<br><br>[runEntity setManagedObjectClassName:@&quot;Run&quot;];<br><br>[mom setEntities:[NSArray arrayWithObject:runEntity]];<br><br>[runEntity release];<br><br>NSMutableArray <em>runProperties = [NSMutableArray array];<br><br>NSAttributeDescription </em>dateAttribute = [[NSAttributeDescription alloc] init];<br><br>[runProperties addObject:dateAttribute];<br><br>[dateAttribute release];<br><br>[dateAttribute setName:@&quot;date&quot;];<br><br>[dateAttribute setAttributeType:NSDateAttributeType];<br><br>[dateAttribute setOptional:NO];<br><br>NSAttributeDescription <em>idAttribute= [[NSAttributeDescription alloc] init];<br><br>[runProperties addObject:idAttribute];<br><br>[idAttribute release];<br><br>[idAttribute setName:@&quot;processID&quot;];<br><br>[idAttribute setAttributeType:NSInteger32AttributeType];<br><br>[idAttribute setOptional:NO];<br><br>[idAttribute setDefaultValue:[NSNumber numberWithInt:0]];<br><br>NSPredicate </em>validationPredicate = [NSPredicate predicateWithFormat:@&quot;SELF &gt;= 0&quot;];<br><br>NSString <em>validationWarning = @&quot;Process ID &lt; 0&quot;;<br><br>[idAttribute setValidationPredicates:[NSArray arrayWithObject:validationPredicate]<br><br>&nbsp;&nbsp;&nbsp; withValidationWarnings:[NSArray arrayWithObject:validationWarning]];<br><br>[runEntity setProperties:runProperties];<br><br>NSMutableDictionary </em>localizationDictionary = [NSMutableDictionary dictionary];<br><br>[localizationDictionary setObject:@&quot;Process ID&quot;<br><br>&nbsp;&nbsp;&nbsp; forKey:@&quot;Property/processID/Entity/Run&quot;];<br><br>[localizationDictionary setObject:@&quot;Date&quot;<br><br>&nbsp;&nbsp;&nbsp; forKey:@&quot;Property/date/Entity/Run&quot;];<br><br>[localizationDictionary setObject:@&quot;Process ID must not be less than 0&quot;<br><br>&nbsp;&nbsp;&nbsp; forKey:@&quot;ErrorString/Process ID &lt; 0&quot;];<br><br>[mom setLocalizationDictionary:localizationDictionary];</span><br><br><span>&nbsp;&nbsp;&nbsp; 这段代码写的比较多，这里不再解释了。本地化字典的代码在最后。创建一个符合&#26684;式的localizationDictionary，然后用model调用即可。</span><br><br></div>

<hr>
<p>本文转载地址:<a href="http://www.cocoachina.com/iphonedev/sdk/2010/1126/2397.html" target="_blank" rel="external">http://www.cocoachina.com/iphonedev/sdk/2010/1126/2397.html</a></p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/5/23 15:20:33 [原文链接](http://blog.csdn.net/kkaxiao/article/details/7594829)
&lt;/div&gt;
&lt;div&gt;
阅读：433 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/7594829#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/05/23/转-Core-Data-编程指南/" data-id="cius3b9h30005g4ifs0x6jdyr" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原-IOS学习书单" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/05/16/原-IOS学习书单/" class="article-date">
  <time datetime="2012-05-16T07:23:16.000Z" itemprop="datePublished">2012-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/05/16/原-IOS学习书单/">[原]IOS学习书单</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说做过的,做说过的—-&lt;非诚勿扰女嘉宾&gt;</p>
<hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 《<span style="text-decoration:underline"><em><strong><span style="font-size:16px">Bundle Programming Guide</span></strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Resource Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Xcode Quick Start Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline">_<strong>ios_developer_program_user_guide__standard_program_v2.7</strong>_</span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>App Development Overview</strong></em></span>》</p>
<p>　　《<em><strong><span style="text-decoration:underline">iphone/ipad crash文件分析方法</span></strong></em>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Blocks Programming Topics</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><strong><em>Core Animation Programming Guide</em></strong></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>iPhone应用程序编程指南</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>View Programming Guide for iOS</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Quartz 2D Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Animation Types and Timing Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Core Animation Cookbook</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Collections Programming Topics</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Timer Programming Topics</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>URL Loading System Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Assertions and Logging Programming Guide</strong></em></span>》</p>
<p>　　《<em><span style="text-decoration:underline"><strong>Preferences and Settings Programming Guide</strong></span></em>》</p>
<p>　　《<span style="text-decoration:underline"><strong><em>Property List Programming Guide</em></strong></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Event-Driven XML Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Local and Push Notification Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>The Objective-C Programming Language</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><strong><em>In-App Purchase Programming Guide</em></strong></span>》</p>
<p>　　《<span style="text-decoration:underline"><strong><em>iAd Programming Guide</em></strong></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Game Kit Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Event Handling Guide for iOS</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Internationalization Programming Topics</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><strong><em>Notification Programming Topics</em></strong></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Concurrency Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Audio Session Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>AV Foundation Programming Guide</strong></em></span>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Core Data Tutorial for iOS</strong></em></span>》</p>
<p>　　《<em><span style="text-decoration:underline"><strong>Key-Value Coding Programming Guide</strong></span></em>》</p>
<p>　　《<span style="text-decoration:underline"><em><strong>Transitioning to ARC Release Notes</strong></em></span>》</p>
<p>　　《<em><strong>Predicate Programming Guide</strong></em>》</p>
<p>　　《<em><strong>Core Data Programming Guide</strong></em>》</p>
<p>　　《<em><strong>Core Data Model Versioning and Data Migration Programming Guide</strong></em>》</p>
<p>　　《<em><strong>Core Data Utility Tutorial</strong></em>》</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 《<strong>Key-Value Observing Programming Guide</strong>》</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/5/16 15:23:16 [原文链接](http://blog.csdn.net/kkaxiao/article/details/7572787)
&lt;/div&gt;
&lt;div&gt;
阅读：615 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/7572787#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/05/16/原-IOS学习书单/" data-id="cius3b9gn0000g4ifwt5wbw3t" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/02/原-net学习框架/">[原].net学习框架</a>
          </li>
        
          <li>
            <a href="/2013/12/02/转-理解和配置-Linux-下的-OOM-Killer/">[转]理解和配置 Linux 下的 OOM Killer</a>
          </li>
        
          <li>
            <a href="/2013/07/16/转-使用epoll实现客户端UDP并发/">[转]使用epoll实现客户端UDP并发</a>
          </li>
        
          <li>
            <a href="/2013/06/27/转-关于Tcp封包/">[转]关于Tcp封包</a>
          </li>
        
          <li>
            <a href="/2012/12/29/转-如何在IOS中使用block/">[转]如何在IOS中使用block</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Ronger<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>