<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[转]如何在IOS中使用block | 观水阁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如何在iOS中使用Block──How to use Blocks with iOSBlock可以帮助我们组织独立的代码段，并提高复用性和可读性。iOS4在UIKit中引入了该特征。超过100个的Apple API都使用了Block，所以这是一个我们必须开始熟悉的知识。
Block是什么样的？&amp;nbsp;
你可以使用^操作符来声明一个Block变量，它表示一个Block的开始。

int&amp;nbsp">
<meta property="og:type" content="article">
<meta property="og:title" content="[转]如何在IOS中使用block">
<meta property="og:url" content="http://yoursite.com/2012/12/29/转-如何在IOS中使用block/index.html">
<meta property="og:site_name" content="观水阁">
<meta property="og:description" content="如何在iOS中使用Block──How to use Blocks with iOSBlock可以帮助我们组织独立的代码段，并提高复用性和可读性。iOS4在UIKit中引入了该特征。超过100个的Apple API都使用了Block，所以这是一个我们必须开始熟悉的知识。
Block是什么样的？&amp;nbsp;
你可以使用^操作符来声明一个Block变量，它表示一个Block的开始。

int&amp;nbsp">
<meta property="og:updated_time" content="2016-10-20T08:24:51.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[转]如何在IOS中使用block">
<meta name="twitter:description" content="如何在iOS中使用Block──How to use Blocks with iOSBlock可以帮助我们组织独立的代码段，并提高复用性和可读性。iOS4在UIKit中引入了该特征。超过100个的Apple API都使用了Block，所以这是一个我们必须开始熟悉的知识。
Block是什么样的？&amp;nbsp;
你可以使用^操作符来声明一个Block变量，它表示一个Block的开始。

int&amp;nbsp">
  
    <link rel="alternate" href="/atom.xml" title="观水阁" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">观水阁</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-转-如何在IOS中使用block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/29/转-如何在IOS中使用block/" class="article-date">
  <time datetime="2012-12-29T12:04:03.000Z" itemprop="datePublished">2012-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [转]如何在IOS中使用block
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如何在iOS中使用Block──How-to-use-Blocks-with-iOS"><a href="#如何在iOS中使用Block──How-to-use-Blocks-with-iOS" class="headerlink" title="如何在iOS中使用Block──How to use Blocks with iOS"></a><a href="http://www.cnblogs.com/pengyingh/articles/2343087.html" target="_blank" rel="external">如何在iOS中使用Block──How to use Blocks with iOS</a></h2><p>Block可以帮助我们组织独立的代码段，并提高复用性和可读性。iOS4在UIKit中引入了该特征。超过100个的Apple API都使用了Block，所以这是一个我们必须开始熟悉的知识。</p>
<p><strong>Block是什么样的？</strong>&nbsp;</p>
<p>你可以使用<em>^</em>操作符来声明一个Block变量，它表示一个Block的开始。</p>
<ol>
<li><span><span class="keyword">int</span><span>&nbsp;num1&nbsp;=&nbsp;7; &nbsp;</span></span></li>
<li><span class="keyword">int</span><span>(^aBlock)(</span><span class="keyword">int</span><span>)&nbsp;=&nbsp;^)</span><span class="keyword">int</span><span>&nbsp;num2)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;num1&#43;nunm2; &nbsp;</span></li>
<li><span>};&nbsp;&nbsp;</span></li>
</ol>
<p>在如上代码中我们将Block声明为一个变量，所以可以将它当做一个函数中使用：</p>
<ol>
<li><span><span>NSLog(@</span><span class="string">&quot;%d&quot;</span><span>,&nbsp;aBlock(49));&nbsp;//adds&nbsp;49&nbsp;</span><span class="keyword">to</span><span>&nbsp;7&nbsp;which&nbsp;gives&nbsp;us&nbsp;56.&nbsp;&nbsp;</span></span></li>
</ol>
<p>我们刚看过了将block当做变量的情况，但通常情况下我们会以内联的方式使用Block，比如在一个变量中。API要么会使用Block在一个对象集合上执行某种操作，要么将其作为一个操作完成后的回调。</p>
<ol>
<li><span><span>NSComperator&nbsp;compareStringsBlock&nbsp;=&nbsp;^(id&nbsp;stringA,&nbsp;id&nbsp;stringB)&nbsp;{ &nbsp;</span></span></li>
<li><span>NSRange&nbsp;rangeS&nbsp;&nbsp;=&nbsp;NSMakeRange&nbsp;(0,&nbsp;[stringA&nbsp;length]); &nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(stringA&nbsp;compare:stringB&nbsp;options:comparisonOptions&nbsp;range:rangeS&nbsp;locale:currentLocale]; &nbsp;</span></li>
<li><span>}; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>NSArray&nbsp;*compareSortArray&nbsp;&nbsp;=&nbsp;[arrayOfStringDays&nbsp;sortArrayUsingComparator:&nbsp;compareStringsBlock]);&nbsp;&nbsp;</span></li>
</ol>
<p>Block具有将临时函数体创建为表达式的优势。Apple文档中指出：&nbsp;</p>
<p>Block是符合如下要求的匿名内联的代码集：</p>
<ul>
<li>和函数一样具有一个指定类型的参数列表</li>
<li>&nbsp;有一个可以推导或声明的返回&#20540;类型</li>
<li>可以从它被定义的词义范围中捕捉状态</li>
<li>可以在需要的时候改变词义范围的状态</li>
<li>可以和相同的词义范围中定义的其他的Block共享更改的可能。</li>
<li>可以在词义范围（堆栈帧）被销毁后继续共享和修改该词义范围（堆栈帧）的状态。</li>
</ul>
<p>Block是一个自包含的小代码段，封装了用于遍历（线性遍历）或者回调，可以并发执行的任务单元。</p>
<p><strong>声明和使用Block</strong>&nbsp;</p>
<p>Apple文档中介绍了如何将一个Block声明为变量，并将其作为一个函数使用：</p>
<ol>
<li><span><span>int&nbsp;(^oneFrom)(int)&nbsp;=&nbsp;^(int&nbsp;anInt)&nbsp;{ &nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;anInt&nbsp;-&nbsp;1; &nbsp;</span></li>
<li><span>}; &nbsp;</span></li>
<li><span>//&nbsp;我们创建了一个内联块^(int&nbsp;anInt)…&nbsp;，其函数体和结果被传到了另外一个名为OneFrom的Block。 &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>printf(&quot;1&nbsp;from&nbsp;10&nbsp;is&nbsp;%d&quot;,&nbsp;oneFrom(10)); &nbsp;</span></li>
<li><span>//&nbsp;打印出：&nbsp;&quot;1&nbsp;from&nbsp;10&nbsp;is&nbsp;9&quot; &nbsp;</span></li>
<li><span>//&nbsp;这个block函数（distanceTraveled）传入3个float型参数，返回float&#20540;。&nbsp; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>float&nbsp;(^distanceTraveled)&nbsp;(float,&nbsp;float,&nbsp;float)&nbsp;= &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^(float&nbsp;startingSpeed,&nbsp;float&nbsp;acceleration,&nbsp;float&nbsp;time)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;</span><span class="attribute">distance</span><span>&nbsp;=&nbsp;(startingSpeed&nbsp;<em>&nbsp;time)&nbsp;&#43;&nbsp;(0.5&nbsp;</em>&nbsp;acceleration&nbsp;<em>&nbsp;time&nbsp;</em>&nbsp;time); &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;distance; &nbsp;</span></li>
<li><span>};&nbsp;</span></li>
</ol>
<p>&nbsp; 你也可以传入一个Block作为一个参数，而不要以如上的方式声明它们，这样就可以在需要将block作为参数的时候以内联代码的方式简单地实现。</p>
<ol>
<li><span><span>NSArray&nbsp;*anArray&nbsp;=&nbsp;[NSArray&nbsp;arrayWithObjects:&nbsp;@</span><span class="string">&quot;cat&quot;</span><span>,&nbsp;@</span><span class="string">&quot;dog&quot;</span><span>,nil]; &nbsp;</span></span></li>
<li><span>sortFunction(anArray,&nbsp;^(string&nbsp;<em>a&nbsp;string&nbsp;</em>b){ &nbsp;</span></li>
<li><span>if&nbsp;(&nbsp;a&nbsp;==&nbsp;@</span><span class="string">&quot;cat&quot;</span><span>)&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">TRUE</span><span>;&nbsp;});&nbsp;</span></li>
</ol>
<p>这样我们就看到一个内联的block代码段占据了最后一个参数（必须是参数列表的最后一个参数）的位置。Cocoa提供了很多使用Block的方法，这样你就可以传入Block作为方法的参数：</p>
<ol>
<li><span><span>NSArray&nbsp;*array&nbsp;=&nbsp;[NSArray&nbsp;arrayWithObjects:&nbsp;@</span><span class="string">&quot;A&quot;</span><span>,&nbsp;@</span><span class="string">&quot;B&quot;</span><span>,&nbsp;@</span><span class="string">&quot;C&quot;</span><span>,&nbsp;&nbsp;nil]; &nbsp;</span></span></li>
<li><span>NSSet&nbsp;*filterSet&nbsp;=&nbsp;[NSSet&nbsp;setWithObjects:&nbsp;@</span><span class="string">&quot;A&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Z&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Q&quot;</span><span>,&nbsp;nil]; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>BOOL&nbsp;(^test)(id&nbsp;obj,&nbsp;NSUInteger&nbsp;idx,&nbsp;BOOL&nbsp;*stop);&nbsp;//Block&nbsp;declaration&nbsp;</span><span class="keyword">returns</span><span>&nbsp;BOOL,&nbsp;params&nbsp;inc.&nbsp;id&nbsp;</span><span class="op">and</span><span>&nbsp;BOOL &nbsp;</span></li>
<li><span>//body&nbsp;</span><span class="keyword">of</span><span>&nbsp;block&nbsp;gets&nbsp;the&nbsp;block&nbsp;literal&nbsp;^(id&nbsp;obj,&nbsp;NSUInteger&nbsp;idx,&nbsp;Bool&nbsp;*stop)…&nbsp;</span><span class="op">and</span><span>&nbsp;the&nbsp;body&nbsp;logic&nbsp; &nbsp;</span></li>
<li><span>test&nbsp;=&nbsp;^&nbsp;(id&nbsp;obj,&nbsp;NSUInteger&nbsp;idx,&nbsp;BOOL&nbsp;*stop)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&amp;lt;&nbsp;5)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([filterSet&nbsp;containsObject:&nbsp;obj])&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;YES; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;</span><span class="keyword">NO</span><span>; &nbsp;</span></li>
<li><span>&nbsp;</span></li>
<li><span>};&nbsp;</span></li>
</ol>
<p>Apple提供的另外一个例子是：</p>
<ol>
<li><span><span>__block&nbsp;BOOL&nbsp;found&nbsp;=&nbsp;</span><span class="keyword">NO</span><span>; &nbsp;</span></span></li>
<li><span>NSSet&nbsp;*aSet&nbsp;=&nbsp;[NSSet&nbsp;setWithObjects:&nbsp;@</span><span class="string">&quot;Alpha&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Beta&quot;</span><span>,&nbsp;@</span><span class="string">&quot;Gamma&quot;</span><span>,&nbsp;@</span><span class="string">&quot;X&quot;</span><span>,&nbsp;nil]; &nbsp;</span></li>
<li><span>NSString&nbsp;*string&nbsp;=&nbsp;@</span><span class="string">&quot;gamma&quot;</span><span>; &nbsp;</span></li>
<li><span>//we&nbsp;provide&nbsp;below&nbsp;a&nbsp;way&nbsp;</span><span class="keyword">of</span><span>&nbsp;how&nbsp;</span><span class="keyword">to</span><span>&nbsp;enumerate,&nbsp;using&nbsp;our&nbsp;own&nbsp;compare&nbsp;logic &nbsp;</span></li>
<li><span>[aSet&nbsp;enumerateObjectsUsingBlock:^(id&nbsp;obj,&nbsp;BOOL&nbsp;*stop)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([obj&nbsp;localizedCaseInsensitiveCompare:string]&nbsp;==&nbsp;NSOrderedSame)&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*stop&nbsp;=&nbsp;YES; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;found&nbsp;=&nbsp;YES; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>}];&nbsp;</span></li>
</ol>
<p>As you can see, it takes a little while to have it sink in but once you get it, it’s quite simple. I suggest looking at Apple’s documentation, as well as looking at the referenced APIs to see how they are used. Practice makes perfect.&nbsp;</p>
<p>&nbsp;</p>
<p>原文出处：<a href="http://answers.oreilly.com/topic/2281-how-to-use-blocks-with-ios/" title="http://answers.oreilly.com/topic/2281-how-to-use-blocks-with-ios/" target="_blank" rel="external">http://answers.oreilly.com/topic/2281-how-to-use-blocks-with-ios/</a></p>
<p>&nbsp;</p>
<p><a href="http://www.j2megame.org/index.php/content/view/2625/165.html" target="_blank" rel="external">objective-c block 详解</a></p>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><div>&nbsp;</div>

<p>Apple 在C, Objective-C, C&#43;&#43;加上Block這個延申用法。目前只有Mac 10.6 和iOS 4有支援。Block是由一堆可執行的程式組成，也可以稱做沒有名字的Function (Anonymous function)。如果是Mac 10.6 或 iOS 4.0 之前的平台可以利用 <a href="http://code.google.com/p/plblocks/" target="_blank" rel="external">http://code.google.com/p/plblocks/</a> 這個project得以支援Block語法。</p>
<p>Apple有一個叫做GCD(Grand Central Dispach)的新功能，用在同步處理(concurrency)的環境下有更好的效率。Block語法產生的動機就是來自於GCD，用Block包好 一個工作量交給GCD，GCD有一個宏觀的視野可以來分配CPU，GPU，Memory的來下最好的決定。</p>
<div><strong><span>Block 簡介</span></strong></div>

<p>Block其實行為和Function很像，最大的差別是在可以存取同一個Scope的變數&#20540;。</p>
<p>Block 實體會長成這樣</p>
<blockquote>
<p><strong>^(</strong>傳入<span>參數列</span><strong>) {</strong><span>行為主體</span><strong>}</strong>;</p>
</blockquote>
<p>Block實體開頭是&quot;^&quot;，接著是由小括號所包起來的<span>參數列</span>(比如 int a, int b, float c)，<span>行為的主體</span>由大括號包起來，專有名詞叫做block literal。<span>行為主體</span>可以用return回傳&#20540;，型別會被compiler自動辦識出來。如果沒有參數列要這樣寫(void)。</p>
<p>看個列子</p>
<blockquote>
<p>^(<span>int a</span>) {<span>return a*a;</span>};</p>
</blockquote>
<p>這是代表Block會回傳輸入&#20540;的平方&#20540;(<span>int a</span>&nbsp;就是<span>參數列</span>，<span>return a*a;</span>&nbsp;就是<span>行為主體</span>)。記得主體裡最後要加&quot;;&quot;因為是敘述，而整個{}最後也要要加&quot;;&quot;因為Block是個物件實體。</p>
<p>用法就是</p>
<blockquote>
<p>int result = ^(int a) {return a<em>a<strong>;</strong>} (5)<em>*;</em></em></p>
</blockquote>
<p>很怪吧。後面小括號裡的5 會被當成a的輸入&#20540;然後經由Block輸出5*5 = 25指定給result這個變數。</p>
<p>有沒有簡單一點的方法不然每次都要寫這麼長？有。接下來要介紹一個叫<strong>Block Pointer</strong>的東西來簡化我們的寫法。</p>
<p><strong>Block Pointer</strong>是這樣宣告的</p>
<blockquote>
<p>回傳&#20540;<span>&nbsp;</span><strong>(^</strong>名字<strong>) (</strong>參數列<strong>)</strong>;</p>
</blockquote>
<p>直接來看一個列子</p>
<blockquote>
<p>int (^<strong>square</strong>) (int);&nbsp;</p>
</blockquote>
<p>// 有一個叫<strong>square</strong>的<strong>Block Pointer</strong>，其所指向的Block是有一個int 輸入和 int 輸出</p>
<blockquote>
<p>square = ^(int a ) {return a*a ;}; // 將剛剛Block 實體指定給 square</p>
</blockquote>
<p>使用Block Pointer的例子</p>
<blockquote>
<p>int result = square(5); // 感覺上不就是funtion的用法嗎？</p>
</blockquote>
<p>也可以把Block Pointer當成參數傳給一個function，比如說</p>
<blockquote>
<p>void myFuction( int (^mySquare) (int) ); // function 的宣告，</p>
</blockquote>
<p>傳入一個有一個int輸入和int輸出的Block 型別的參數</p>
<p>呼叫這個myFunction的時候就是這樣呼叫</p>
<blockquote>
<p>int (^mySqaure) (int) = ^(int a) {return a*a;};<br>// 先給好一個有實體的block pointer叫mySquare</p>
</blockquote>
<p>&nbsp;</p>
<blockquote>
<p>myFunction( mySqaure ) ; //把mySquare這個block pointer給myFunction這個function</p>
</blockquote>
<p>或是不用block pointer 直接給一個block 實體，就這樣寫</p>
<blockquote>
<p>&nbsp;myFunction(&nbsp;<strong>&nbsp;^(int a) {return a*a}</strong>&nbsp;) ;</p>
</blockquote>
<p>當成Objective-C method 的傳入&#20540;的話都是要把型別寫在變數前面然後加上小括號，因些應該就要這樣寫</p>
<blockquote>
<p>-(void) objcMethod:(&nbsp;<strong>int (^) (int)</strong>&nbsp;) square; // square 變數的型別是 int (^) (int)</p>
</blockquote>
<p>讀文至此是不是對Block有基本的認識？ 接下來我們要談談Block相關的行為和特色</p>
<p>首先是來看一下在Block裡面存取外部變數的方法</p>
<div><span><strong>存取變數</strong></span></div>

<p>1. 可以讀取和Block pointer同一個scope的變數&#20540;：</p>
<blockquote>
<p>{</p>
<p>int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) {return outA&#43;a;};</p>
<p>// block 裡面可以讀同一個scope的outA的&#20540;</p>
<p>int result = myPtr(3); // result is 11</p>
<p>}</p>
</blockquote>
<p>我們再來看一個很有趣的例子</p>
<blockquote>
<p>{</p>
<p>int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) {return outA&#43;a;};</p>
<p>// block 裡面可以讀同一個scope的outA的&#20540;</p>
<p><strong>outA = 5;</strong>&nbsp;// 在呼叫myPtr之前改變outA的&#20540;</p>
<p>int result = myPtr(3); // result 的&#20540;還是&nbsp;<strong>11</strong>並不是<strong>&nbsp;8</strong></p>
<p>}</p>
</blockquote>
<p>&nbsp;事實上呢，myPtr在其主體用到outA這個變數&#20540;的時候是做了一個copy的動作把outA的&#20540;copy下來。所以之後outA即使換了新的&#20540;對於myPtr裡copy的&#20540;是沒有影響到的。</p>
<p>要注意的是，這個指的&#20540;是變數的&#20540;，如果這個變數的&#20540;是一個記憶體的位置，換句話說，這個變數是個pointer的話，它指到的&#20540;是可以在block裡被改變的。</p>
<blockquote>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSMutableArray * mutableArray = [NSMutableArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;,nil];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = ^(int a) { [mutableArray removeLastObject];&nbsp; return a*a;} (5);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;test array %@&quot;, mutableArray);</p>
<p>}</p>
</blockquote>
<p>原本mutableArray的&#20540;是{@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;}在block裡被更改mutableArray所指向的物件後，mutableArray的&#20540;就會被成{@&quot;one&quot;,@&quot;two&quot;}</p>
<p>2. 直接存取static 的變數&nbsp;</p>
<blockquote>
<p>{</p>
<p>static int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) {return outA&#43;a;};</p>
<p>// block 裡面可以讀同一個scope的outA的&#20540;</p>
<p><strong>outA = 5;</strong>&nbsp;// 在呼叫myPtr之前改變outA的&#20540;</p>
<p>int result = myPtr(3); // result 的&#20540;是<strong>&nbsp;8</strong>，因為outA是個static 變數會直接反應其&#20540;</p>
<p>}</p>
</blockquote>
<p>甚至可以在block裡面直接改變outA的&#20540;比如這樣寫</p>
<blockquote>
<p>{</p>
<p>static int outA = 8;</p>
<p>int (^myPtr) (int) = ^(int a) { outA= 5; return outA&#43;a;};</p>
<p>// block 裡面改變outA的&#20540;</p>
<p>int result = myPtr(3); // result 的&#20540;是<strong>&nbsp;8</strong>，因為outA是個static 變數會直接反應其&#20540;</p>
<p>}</p>
</blockquote>
<p>3. Block Variable</p>
<p>在某個變數前面如果加上修飾字<span><em></em></span><span></span>block 的話(注意block前有兩個下底線)，這個變數又稱為block variable。那麼在block裡就可以任意修改此變數&#20540;，變數&#20540;的改變也可以知道。</p>
<blockquote>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp; __block int num = 5;</p>
<p>&nbsp;&nbsp;&nbsp; int (^myPtr) (int) = ^(int a) { return num&#43;&#43;;};</p>
<p>&nbsp;&nbsp;&nbsp; int (^myPtr2) (int) = ^(int a) { return num&#43;&#43;;};</p>
<p>&nbsp;&nbsp;&nbsp; int result = myPtr(0);</p>
<p>&nbsp;&nbsp;&nbsp; result = myPtr2(0);</p>
<p>}</p>
</blockquote>
<p>因為myPtr和myPtr2都有用到num這個block variable，最後result的&#20540;就會是7</p>
<div><strong><span>生命周期和記憶體管理</span></strong></div>

<p>因為block也是繼承自NSObject，所以其生命周期和記憶體的管理也就非常之重要。</p>
<p>block一開始都是被放到stack裡，換句話說其生命周期隨著method或function結束就會被回收，和一般變數的生命周期一樣。</p>
<p>關於記憶體的管理請遵循這幾個要點</p>
<p>1. block pointer的實體會在method或function結束後就會被清掉</p>
<p>2. 如果要保存block pointer的實體要用-<span>copy</span>指令，這樣block pointer就會被放到heap裡</p>
<p>&nbsp;&nbsp;&nbsp; 2.1 block 主體裡用到的block variable 也會被搬到heap 而有新的記憶體位置，且一並更新有用到這個block variable 的block都指到新的位置</p>
<p>&nbsp; &nbsp; 2.2 一般的variable&#20540;會被copy&nbsp;</p>
<p>&nbsp; &nbsp; 2.3 如果主體裡用到的variable是object的話，此object會被retain, block release時也會被release</p>
<p>&nbsp;&nbsp;&nbsp; 2.4 __block variable 裡用到的object是不會被retain的</p>
<p>首先來看一下這個例子</p>
<blockquote>
<p>typedef int (^MyBlock)(int);</p>
<p>MyBlock genBlock();</p>
<p>int main(){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock&nbsp;<strong>outBlock</strong>&nbsp;= genBlock();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = outBlock(5);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;result is %d&quot;,[outBlock retainCount] ); // segmentation fault</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;result is %d&quot;,result&nbsp; );</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0 ;</p>
<p>}</p>
<p>MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock&nbsp;<strong>inBlock</strong>&nbsp;= ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;<strong>inBlock</strong>&nbsp;;</p>
<p>}</p>
</blockquote>
<p>此程式由genBlock裡產生的block再指定給main function的<strong>outBlock</strong>變數，執行這個程式會得到</p>
<p>Segmentation fault</p>
<p>(註：有時候把 genBlock裡的a 去掉就可以跑出結果的情形，這是系統cache住記憶體，並不是inBlock真得一直存在，久了還是會被回收，千萬不要以為是對的寫法)</p>
<p>表示我們用到了不該用的記憶體，在這個例子的情況下是在genBlock裡的<strong>inBlock</strong>變數在return的時候就被回收了，<strong>outBlock</strong>無法有一個合法的記憶體位置-retainCount就沒意義了。</p>
<p>如果這個時候需要保留inBlock的&#20540;就要用-copy指令，將genBlock改成</p>
<blockquote>
<p>&nbsp;MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [inBlock&nbsp;<span>copy</span>]&nbsp; ;</p>
<p>}</p>
</blockquote>
<p>這樣[inBlock copy]的回傳&#20540;就會被放到heap，就可以一直使用(記得要release)</p>
<p>執行結果是</p>
<p>result is 1</p>
<p>result is 15</p>
<p>再次提醒要記得release outBlock。</p>
<p>如果一回傳[inBlock copy]的&#20540;就不再需要的時候可以這樣寫</p>
<blockquote>
<p>&nbsp;MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [[inBlock&nbsp;<span>copy</span>]&nbsp;<span>autorelease</span>] ;</p>
<p>}</p>
</blockquote>
<p>-copy指令是為了要把block 從stack搬到heap，autorelease是為了平衝retainCount加到autorelease oop ，回傳之後等到事件結束就清掉。</p>
<p>接下來是block存取到的local variable是個物件的型別，然後做copy 指令時</p>
<blockquote>
<p>MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSMutableString * myString = [NSMutableString string];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;retain count of string %d&quot;,[myString retainCount]);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [inBlock copy] ;</p>
<p>}</p>
</blockquote>
<p>結果會印出</p>
<p>retain count of string 2</p>
<p>這個結果和上面2.3提到的一樣，local variable被retain了</p>
<p>那再來試試2.4，在local variable前面加上__block</p>
<blockquote>
<p>MyBlock genBlock() {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int a = 3;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>__block</span>&nbsp;NSMutableString * myString = [NSMutableString string];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyBlock inBlock = ^(int n) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSLog(@&quot;retain count of string %d&quot;,[myString retainCount]);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n*a;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return [inBlock copy] ;</p>
<p>}</p>
</blockquote>
<p>執行的結果就是會</p>
<p>retain count of string 1</p>
<div><strong><span>Block Copying注意事項</span></strong></div>

<p>如果在Class method裡面做copying block動作的話</p>
<p>1. 在Block裡如果有直接存取到self，則self會被retain</p>
<p>2. 在Block裡如果取存到instance variable (無論直接或是從accessor)，則self會被retain</p>
<p>3. 取存到local variable所擁有的object時，這個object會被retain</p>
<p>讓我們來看一個自訂的Class</p>
<blockquote>
<p><span>@interface</span>&nbsp;MyObject : NSObject {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NSString * title;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (^<span>myLog</span>) (NSString * deco);</p>
<p>}</p>
<p>-(void) logName;</p>
<p><span>@end</span></p>
<p><span>@implementation</span>&nbsp;MyObject</p>
<p>-(id) initWithTitle:(NSString * ) newTitle{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(self = [super init]){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title = newTitle;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>myLog</span>&nbsp;= [^(NSString * deco)&nbsp;<span>{</span>&nbsp;NSLog(@&quot;<span>%@%@%@</span>&quot;,deco, title, deco );<span>}</span>&nbsp;<span>copy</span>];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self;</p>
<p>}</p>
<p>-(void) logName{</p>
<p>&nbsp;myLog(@&quot;==&quot;);</p>
<p>}</p>
<p>-(void ) dealloc{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [myLog release];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [title release];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [super dealloc];</p>
<p>}</p>
<p><span>@end</span></p>
</blockquote>
<p>在main 裡使用如下</p>
<p>&nbsp;MyObject * mObj = [[MyObject alloc]&nbsp;<span>initWithTitle</span>:@&quot;Car&quot;];</p>
<p>&nbsp;NSLog(@&quot;retainCount of MyObject is&nbsp; %d&quot;,[mObj retainCount]&nbsp; );</p>
<p>&nbsp;[mObj logName];</p>
<p>其執行的結果為</p>
<p>retainCount of MyObject is&nbsp;<span>&nbsp;<span>2</span></span></p>
<p>==Car==</p>
<p>因為在MyObject的建構子裡myLog這個block pointer用了title這個instance variable然後就會retain self也就是MyObject的物件。</p>
<p>盡量不要這樣寫，會造成retain cycle，改善的方法是把建構子改成這樣</p>
<blockquote>
<p>-(id) initWithTitle:(NSString * ) newTitle{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(self = [super init]){</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; title = newTitle;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>myLog</span>&nbsp;= [^(NSString * deco)&nbsp;<span>{</span>&nbsp;NSLog(@&quot;<span>%@%@%@</span>&quot;,deco,&nbsp;<span>newTitle</span>, deco );<span>}</span>&nbsp;<span>copy</span>];</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self;</p>
<p>}</p>
</blockquote>
<p>在Block主體裡用newTitle這個變數而不是title。這樣self就不會被retain了。</p>
<p>最後談一個小陷井</p>
<p>void (^myLog) (void);&nbsp;</p>
<p>BOOL result ;</p>
<p>if(result)</p>
<p>&nbsp;&nbsp;&nbsp; myLog = ^ {NSLog(@&quot;YES&quot;);};</p>
<p>else</p>
<p>&nbsp;&nbsp;&nbsp; myLog = ^ {NSLog(@&quot;NO&quot;);};</p>
<p>myLog();</p>
<p>這樣很可能就會當掉了，因為myLog 實體在if 或是else結束後就被清掉了。要記得。</p>
<p>要用copy來解決這個問題，但要記得release。</p>
<pre><code>&lt;div&gt;
    作者：kkaxiao 发表于2012/12/29 20:04:03 [原文链接](http://blog.csdn.net/kkaxiao/article/details/8451431)
&lt;/div&gt;
&lt;div&gt;
阅读：379 评论：0 [查看评论](http://blog.csdn.net/kkaxiao/article/details/8451431#comments)
&lt;/div&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2012/12/29/转-如何在IOS中使用block/" data-id="cius3b9h60006g4if8jvw1sha" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2013/06/27/转-关于Tcp封包/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          [转]关于Tcp封包
        
      </div>
    </a>
  
  
    <a href="/2012/11/03/转-APNS/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">[转]APNS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">November 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">August 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/02/原-net学习框架/">[原].net学习框架</a>
          </li>
        
          <li>
            <a href="/2013/12/02/转-理解和配置-Linux-下的-OOM-Killer/">[转]理解和配置 Linux 下的 OOM Killer</a>
          </li>
        
          <li>
            <a href="/2013/07/16/转-使用epoll实现客户端UDP并发/">[转]使用epoll实现客户端UDP并发</a>
          </li>
        
          <li>
            <a href="/2013/06/27/转-关于Tcp封包/">[转]关于Tcp封包</a>
          </li>
        
          <li>
            <a href="/2012/12/29/转-如何在IOS中使用block/">[转]如何在IOS中使用block</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Ronger<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>